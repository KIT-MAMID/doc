\section{Design Improvements}

In accordance with the project supervisor, a text-based delta between the original and implemented application design
is beyond the scope of this document.

However, to facilitate understanding and future maintenance of the code base, the design document has been updated to the state of
the implementation at the time of writing this document.

The purpose of this section is to provide an overview of the reasoning behind the design changes.

% one subsection per problem encountered during implementation

\subsection{Master: Database-Related Changes}

During the design phase of the project, it was decided to use the \refgo{gorm} ORM layer and a relational database as the backing store
for \mamid application data.

While never officially stated, the developers assumed SQlite 3 to be sufficient for the purposes of \mamid.

This assumption was proven wrong when enough of the master modules were implemented to reveal the limited capabilities of SQlite 3 regarding
concurrent access: updating a single row or column in the database effectively requires an exclusive lock on the entire database (see https://www.sqlite.org/lockingv3.html).
The various master components however udpate (disjoint!) rows or columns in parallel.

Given a substantial part of the master codebase had already been written expecting this behavior, the developers decided to switch to
PostgreSQL, a well-established open source relational database (see https://www.postgresql.org/).

PostgreSQL
\begin{itemize}
\item compiles in its most recent version 9.5.4 on the primary target operating system \textit{OpenIndiana 151a9} (also with TLS support)
\item allows for the degree of parallel database access required by the master
\item has features like foreign keys, data type checking and referential actions enabled by default %TODO ref
\item allows for redundant deployments \& zero downtime backups through the \codeinline{pg\_dump(1)} utility (optional criteria) %TODO ref
\item thus significantly reduces the risk of a corrupted database.
\end{itemize}

However, switching to PostgreSQL revealed flaws in the database schema auto-generated by the \refgo{gorm} ORM layer:

\begin{itemize}
\item Foreign keys and referential actions need to be defined as Go Field Tags in the model definition.
\item Schema migrations are only half-heartedly supported.
\end{itemize}

It was decided to define the database schema in plain SQL and to implement support for creating and migrating the schema in \mamid. %TODO this ok?

Effortless compatibility to \refgo{gorm} is maintained by following the documented conventions for naming columns (see http://jinzhu.me/gorm/models.html\#conventions) .

\subsection{Master: Cluster Allocator Prioritization Datastructures}

The \refgo{master.ClusterAllocator} is crucial for the stable operation of the \mamid-managed cluster.

The design document contains a pseudocode implementation of the \refgo{master.ClusterAllocator} algorithms managing Replica Set members.

However, pseudocode usually does not map directly to the concrete implementation.

For the implementation of MAMID, the priority queue datastructures used in the Cluster Allocator pseudocode proved impractical to implement:

\begin{itemize}
\item The master architecture follows the \textit{repository pattern}, meaning that decoupled components work together by sharing data
through the central database.
\item The Cluster Allocator algorithms need read access to a a substantial amount of the cluster model stored in the database
      in order to make allocation decisions.
\item The \refgo{gorm} ORM layer cannot record fine-grained changes to objects (missing dynamism in Go).
      Hence, saving updates to an object graph to database leads to an update of all attributes,
      inducing conflicting transactions with other components of MAMID.
\item Keeping the priority queue datastructures in sync with the database state during a \refgo{master.ClusterAllocator} run
      appears to be impossible with \refgo{gorm}.
\end{itemize}

Given these problems, the priority queues where replaced by SQL queries encoding the prioritization criteria.
Several SQL views were introduced to keep the prioritization queries concise and improve performance.
Testing did not reveal performance problems with the \refgo{master.ClusterAllocator} implementation.

\subsection{Replica Set deployment procedure with keyfiles far more complicated than expected}

Took 3 days to get right.

=> Keyfiles for internal authentication => required keyfile deployment
=> Keyfiles in turn require User Access Control  => require configuration of management user

==> this information needs to be presented to the administrator if he/she wants to actually use deployed replica sets
    (e.g. app user configuration, sharding configuration, etc)
    => extend GUI for a System view
      => additional API endpoints for Keyfiles and Management User Credential
    => extend Master, MSP and Slave to support deployment of this information
       (shortcut taken: unchangeable)

\subsection{Slave: Mongod \& Replica Set configuration far more edge cases than expected}

elaborate on the process of deploying a ReplicaSet, possible a UML activity diagram

=> Configurator logic became unmaintainable because one could not see the forest from the trees
  => implementation of MongoDB API wrapper to increase oversight (wording?) in MongodConfigurator logic

=> Additional MSP endpoint needed to be created for replica set initiiation since it must happen from a single machine
   (requires global coordination form the master)

  => Replica Set Config (Priorities, NumberOfVotes) needs ot be communicated to the Slave initiating the Replica Set


\subsection{We realized: administrator needs more details on the deployment of the cluster in order to use it for applications}

=> GUI needs to display more information
    - Mongods of Replica Sets
    => requirement for Mongod API endpoint (expose what is already in the Master database)

=> Useful gimmics for the admin: ready to copy-to-clipboard 
    - command lines for starting a sharding config server
    - MongoDB URL useful for pasting into application configuration running on top of a Replica Set

\subsection{Original GUI draft does not scale well to 80-100 machines }

- use dense UI elements
- implement filtering functionality (cheap win using Angular!)

\subsection{Notifier config file}

A config file was added to the notifier to make the deployment easier for the administrator. The config file contains the SMTP relay host 
information, the master api endpoint and the path to the contacts file in a ini file. Also the api endpoint informtaion is used to generate 
links to affected Slaves \& Replica Sets in the notification e-mails.
