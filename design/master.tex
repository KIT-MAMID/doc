\newtheorem{theorem}{Theorem}


\section{Master: Model}% cannot use subsections here because helpers macros have fixed sectioning-hierarchy
\renewcommand{\gocurpackage}{model}

The \refgo{model} package encapsulates all datastructures used to model the cluster managed by mamid

stored in database:
\struct{Slave}{
	A \refstruct{Slave} models an instance of the \mamid slave application running on a host.
}{
  \property{Id}[uint]{Unique id.}
  \property{Hostname}[string]{Hostname of the host the slave is running on. \refproperty{Hostname} uniquely identifies a host in the cluster.} 
  \property{Port}[uint]{Port where the slave listens for connections from the master.}
  \property{MongodPortRangeBegin}[uint]{Beginning of the range of ports spawned \refstruct{Mongod} may listen on (inclusive).}
  \property{MongodPortRangeEnd}[uint]{End of the range of ports spawned \refstruct{Mongod} may listen on (exclusive). Implicitly specifies together with \refproperty{MongodPortRangeBegin} how many \refstruct{Mongod}s may be spawned on the slave.}
  \property{PersistentStorage}[bool]{Whether the slaves data directory is on persistent storage or volatile storage.}
  \property{ConfiguredState}[\refenum{SlaveState}]{The state of the slave set by the user.}
  \property{RiskGroup}[\refstruct{RiskGroup}]{The risk group the slave is in.}
  \property{Mongods}[[]\refstruct{Mongod}]{The \refstruct{Mongod}s that are running or should run on this slave.}
}

\goenum{SlaveState}
{}
{
	\goenumitem{Active}{Slaves in active mode are available to host Mongod instances. They are monitored and the administrator is notified of problems on the slave.}
	\goenumitem{Maintenance}{Slaves in maintenance mode are not monitored but running Mongods will not be stopped.}
	\goenumitem{Disabled}{Slaves in disabled mode are not monitored. The Mongod instances running on disabled slaves will be migrated to active slaves.}
}

\struct{RiskGroup}{
  A \refstruct{RiskGroup} models a set of slaves sharing a common risk of failure. A \refstruct{Slave} belongs to one \refstruct{RiskGroups}.
}{
  \property{Id}[uint]{Unique id.}
  \property{Name}[string]{Name of the risk group.}
  \property{Slaves}[[]\refstruct{Slave}]{The \refstruct{Slave}s belonging to this \refstruct{RiskGroup}}
}

\struct{ReplicaSet}{
	A \refstruct{ReplicaSet} models a MongoDB replica set consisting of multiple \refstruct{Mongod}s.
}{
  \property{Id}[uint]{Unique id.}
  \property{Name}[string]{Name of the replica set.}
  \property{PersistentMemberCount}[uint]{Number of persistent \refstruct{Mongod}s that should be part of this \refstruct{ReplicaSet}.}
  \property{VolatileMemberCount}[uint]{Number of volatile \refstruct{Mongod}s that should be part of this \refstruct{ReplicaSet}.}
}
  MongodExecutionState
  HostPort
  Problem

\struct{Mongod}{
  An instance of \refstruct{Mongod} is uniquely identified by
  \begin{itemize}
    \item its parent slave (the machine it is running on)
    \item the port it is listening on
    \item the replica set it belongs to.
  \end{itemize}

  The two attributes \refproperty{DesiredState} and \refproperty{ObservedState} are both optional.

  The role of a Mongod process depends on the permutations of \codeinline{nil} and $\not=\codeinline{nil}$
    assignments and is depicted in the table below:
 
  \begin{figure}[H]
  \centering
  \begin{tabularx}{0.6\linewidth}{|c|X|X|}
          \hline
          \diaghead{lengthofthediagheads}{\codeinline{DesiredState}}{\codeinline{ObservedState}} & $=\codeinline{nil}$ & $\not= \codeinline{nil}$ \\\hline
          $=\codeinline{nil}$       & \text{not existent} & zombie  \\\hline
          $\not= \codeinline{nil}$  & not spawned & present \\\hline
  \end{tabularx}
  \caption{Mongod role by \codeinline{DesiredState} \& \codeinline{ObservedState}}
  \end{figure}

}{
  \property{Port}[PortNumber]{Port number the Mongod is listening on.}
  \property{ReplSetName}[string]{Name of the Mongods replica set. A Mongod is always in exactly one replica set.}
  \property{ObservationError}[error]{Latest error that occurred when attempting to update the \refproperty{Mongod.ObservedState}.\\
                                     \codeinline{nil} if no error occurred on last attempt.}
  \property{LastEstablishStateError}[SlaveError]{Latest error reported by the slave when attempting to establish
                                                the \refproperty{Mongod.DesiredState}.\\
                                                \codeinline{nil} if no error occurred on last attempt.}
\property{DesiredState}[MongodState]{State the Mongod should be in. \codeinline{nil} if no desired state has been set.}
  \property{ObservedState}[MongodState]{State the Mongod was last observed to be in. \codeinline{nil} if no observation has been made.}
}

\struct{MongodState}{
        Description of state of a particular \refstruct{Mongod} that is not already contained in \refgo{model.Mongod}.
}{
  \property{IsShardingConfigServer}[bool]{indicates whether the Mongod is configured as a Sharding config server.}
  \property{ExecutionState}[MongodExecutionState]{execution state of the Mongod process.}
  \property{ReplicaSetMembers}[HostPort]{Replica Set members as reported by the Mongod process.}
}


\goenum{MongodExecutionState}{
  The different states of a Mongod that are relevant to the implementation of \mamid.

  The following value definitions are ordered by availibility of data in the particular state.
}{
  \goenumitem{Destroyed}{Mongod data directory not present and Mongod not running.}
  \goenumitem{NotRunning}{Data directory present but not Mongod running.}
  \goenumitem{Recovering}{Mongod running but not available for reads because data needs to be synced from other Replica Set members.
                          Common when adding new members to an existing Replica Set.}
  \goenumitem{Running}{Mongod running and in sync with other Replica Set members. }
}

\struct{HostPort}{
  Tuple of $(hostname, port)$ that is a Mongod's identifier for Replica Set members.
}{
  \property{Hostname}[string]{The hostname of the Replica Set member.\\
                              For a given \refgo{model.HostPort.gostname} a \refgo{model.Slave}
                              with the same \codeinline{Hostname} should exist.\\
                              Otherwise, there exists a Mongod in the cluster that is not managed by \mamid.}
  \property{Port}[PortNumber]{The port on the host identified by \refproperty{Hostname} on which the
                              Replica Set member is listening.}
}

\struct{Problem}{
  Representation of a problem or error that occurred during operation of the \refgo{master}.

  The references to \refstruct{Slave}, \refstruct{ReplicaSet} and \refstruct{Mongod} enable searchability
  of the \refstruct{Problem} list.
  If all references are \codeinline{nil}, the problem is still legitimate and should be reported by a user interface or alerting system.

  See \refgo{master.ProblemManager} for the transformation from errors to \refgo{master.Problem}.
}{
  \property{Id}[uint]{Unique ID of the problem. If the \emph{same} problem occurrs after it was resolved before,
                      its different incarnations are distinguishable by their \refproperty{Id}.}
                      %TODO really necessary? problem is uniquely identified by (Slave, ReplicaSet, Mongod)
  \property{Description}[string]{Short human-readable description of the problem, suitable for subject lines of error messages.}
  \property{LongDescription}[string]{Long human-readable description of the problem.\\
                                     Can contain the \codeinline{error.Error()} of one or more underlying errors.}
  \property{FirstOccurred}[time.Time]{The point in time when the particular problem first occurred.}
  \property{LastUpdated}[time.Time]{The point in time when the particular problem was last observed, e.g. the time of the last monitor run.}
  \property{Slave}[*Slave]{A reference to a \refstruct{Slave} from which the problem originated. May be \codeinline{nil}}
  \property{ReplicaSet}[*ReplicaSet]{A reference to a \refstruct{ReplicaSet} form which the problem originated. May be \codeinline{nil}}
  \property{Mongod}[*Mongod]{A reference to a \refstruct{Mongod} from where the problem originated. May be \codeinline{nil}}
}

data transfer objects (used to communicate via the master.Bus)

  DesiredReplicaSetConstraintStatus
  MongodMatchStatus
  ConnectionStatus
  ObservedReplicaSetConstraintStatus


\section{Master: Main Package}
\renewcommand{\gocurpackage}{master}

The Master (\refgo{master}) is the most complex component of \mamid.

fulfills many diff tasks, running in separate goroutines

different tasks need to communicate with each other
  shared persistent database with ORM abstraction 'gorm' => see model for which objcets
  status information (similar to observer pattern), realized through a Bus that leverages Golang's channels
    messages sent over bus are structs suffixed with .*Status
    generally, bus messages are sent repeatedly => != edge-triggered notifications
    encapsulate enough information about a type of status of an object in the database
      other components on the bus can react to information
=> loose coupling of components

\struct{Deployer}{
	The \refstruct{Deployer} listens on the bus for \refgo{model.MongodMismatchStatus} objects with \refgo{Mismatch} set to true and deployes the desired state of the affected mongod using the \refgo{msp.MSPClient}
}{
	\property{DB}[gorm.DB]{Initialized handle to the database.}
	\property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.}
}{
	\method{Run}{Waits for \refgo{model.MongodMismatchStatus} objects and runs \refmethod{pushMongodState} when a mismatch occurrs.}
	\method{pushMongodState}
	(
		\param{mongod}[model.Mongod]{The mongod to push the state to.}
	){
		Gets the desired state of \refparam{mongod} from the database and pushes it using the \refgo{msp.MSPClient}.
	}
}

\struct{Monitor}{
	The \refstruct{Monitor} uses the \refgo{msp.MSPClient} to ask all slaves for their mongod's states, saves the observed state in the database and compares the observed state to the desired state from the database. It publishes \refgo{model.MongodMismatchStatus} objects with the result of each comparison on the bus.
}{
	\property{DB}[gorm.DB]{Initialized handle to the database.}
	\property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.}
}{
	\method{Run}{Periodically fetches the mongods' states from the slaves, saves it in the database, compares it to the desired state using \refmethod{compareStates} and publishes the result on the bus as a \refgo{model.MongodMismatchStatus} object.}
	\method{compareStates}[MongodMatchStatus]
	(
		\param{mongod}[model.Mongod]{The mongod to compare the state of}
	){
		Compares the \refgo{model.Mongod.ObservedState} and \refgo{model.Mongod.DesiredState} for mismatches and returns the result as a \refgo{model.MongodMismatchStatus}.
	}
}

\struct{ProblemManager}{
	The \refstruct{ProblemManager} listens on the bus for \refgo{model.StatusMessage}s, checks if they represent an error and generates or removes a problem and saves the changes in the database.
}{
	\property{DB}[gorm.DB]{Initialized handle to the database.}
	\property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.}
}{
	\method{Run}{Listens for \refgo{model.StatusMessage}s on the bus and checks if they respresent an error.
		If they do, generates a problem using \refmethod{generateProblem} and stores it in the database.
		It they don't, checks if the database contains a problem of the same type for the same object and removes it.}
	\method{generateProblem}[Problem]
	(
		\param{e}[StatusMessage]{}
	){
		
	}
}

\struct{ClusterAllocator}{
  The \refstruct{ClusterAllocator} determines the layout of the cluster managed by \mamid.

  It attempts to fulfill the constraints defined through the model objects, in particular
  \begin{itemize}
    \item A \refgo{model.ReplicaSet}'s \refgo{VolatileNodeCount} \& \refgo{PersistentNodeCount}
    \item The \refgo{model.Slave}'s allowed number of Mongod instances
          (\refgo{MongodPortRangeBegin} to \refgo{MongodPortRangeEnd}).
    \item The \refgo{model.Slave.SlaveState}
    \item The configured \refgo{model.RiskGroup}s.
  \end{itemize}

  An iterative algorithm is employed to decide on a cluster layout described through
  \refgo{model.Mongod.DesiredState}s that
  \begin{itemize}
    \item attempts to fulfill the above constraints
    \item attempts an even distribution of Mongods on the different cluster hosts
    \item is a minimal change in comparison to the previous layout
  \end{itemize}

  \begin{theorem}{Idempotence of the ClusterAllocator}
    \label{theorem:idempotence_clusterallocator}
    Let $l$ be a layout of the cluster. Then $ClusterAllocator(ClusterAllocator(l)) = ClusterAllocator(l)$.
  \end{theorem}

}{
  \property{DB}[gorm.DB]{Initialized handle to the database.}
  \property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.} %TODO ref}
}{
  \method{LayoutCluster}{Lay out the cluster as described above.}
}

\subsubsection{Pseudocode}

The \refstruct{master.ClusterAllocator} is crucial to the stable operation of the \mamid-managed cluster.\\
Hence, it is worth defining the implementation of \refgo{master.ClusterAllocator.LayoutCluster} through pseudocode. %TODO parentheses

While studying the algorithms below, the reader should keep in mind that
\begin{itemize}
  \item changes in the cluster layout $\equiv$ change or creation of \refgo{model.Mongod.DesiredState} 
  \item the \refgo{model.Mongod.ObservedState} may change after an arbitrary amount of time or even not at all
  \item changes to a ReplicaSet must not violate or further worsen the high-availibility constraints,
        in particular \refgo{model.ReplicaSet}'s \refgo{VolatileNodeCount} \& \refgo{PersistentNodeCount}\\
        $\implies$ Mongods in \refgo{model.MongodExecutionState.Recovering} are an important special-case.
\end{itemize}

\input{master_pseudocode_clusterallocator}
