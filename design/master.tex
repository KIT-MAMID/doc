\newtheorem{theorem}{Theorem}


\section{master}

\renewcommand{\gocurpackage}{model}
\renewcommand{\gocurpackage}{master}

\struct{ClusterAllocator}{
  The \refstruct{ClusterAllocator} determines the layout of the cluster managed by \mamid.

  It attempts to fulfill the constraints defined through the model objects, in particular
  \begin{itemize}
    \item A \refgo{model.ReplicaSet}'s \refgo{VolatileNodeCount} \& \refgo{PersistentNodeCount}
    \item The \refgo{model.Slave}'s allowed number of Mongod instances
          (\refgo{MongodPortRangeBegin} to \refgo{MongodPortRangeEnd}).
    \item The \refgo{model.Slave.SlaveState}
    \item The configured \refgo{model.RiskGroup}s.
  \end{itemize}

  An iterative algorithm is employed to decide on a cluster layout described through
  \refgo{model.Mongod.DesiredState}s that
  \begin{itemize}
    \item attempts to fulfill the above constraints
    \item attempts an even distribution of Mongods on the different cluster hosts
    \item is a minimal change in comparison to the previous layout
  \end{itemize}

  \begin{theorem}{Idempotence of the ClusterAllocator}
    \label{theorem:idempotence_clusterallocator}
    Let $l$ be a layout of the cluster. Then $ClusterAllocator(ClusterAllocator(l)) = ClusterAllocator(l)$.
  \end{theorem}

}{
  \property{DB}[gorm.DB]{Initialized handle to the database.}
  \property{BusChannel}[chan interface{}]{Initialized channel to the application bus.} %TODO ref}
}{
  \method{LayoutCluster}{Lay out the cluster as described above.}
}

\subsubsection{Pseudocode}

The \refstruct{master.ClusterAllocator} is crucial to the stable operation of the \mamid-managed cluster.\\
Hence, it is worth defining the implementation of \refgo{master.ClusterAllocator.LayoutCluster} through pseudocode. %TODO parentheses

While studying the algorithms below, the reader should keep in mind that
\begin{itemize}
  \item changes in the cluster layout $\equiv$ change or creation of \refgo{model.Mongod.DesiredState} 
  \item the \refgo{model.Mongod.ObservedState} may change after an arbitrary amount or even never.\\
  \item changes to a ReplicaSet must not violate or further worsen the high-availibility constraints,
        in particular \refgo{model.ReplicaSet}'s \refgo{VolatileNodeCount} \& \refgo{PersistentNodeCount}\\
        $\impl$ Mongods in \refgo{model.MongodExecutionState.Recovering} are an important special-case.
\end{itemize}

\input{master_pseudocode_clusterallocator}
