\newtheorem{theorem}{Theorem}


\section{Master: Model}% cannot use subsections here because helpers macros have fixed sectioning-hierarchy
\beginpackage{model}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{model_classes}
	\caption{Model}
\end{figure}

The \refgo{model} package contains all datastructures used to model the cluster managed by \mamid.

The structures implementing the \codeinline{StatusMessage} interface are used to pass status information on the application internal bus (\refgo{master.Bus}).

The other structures in \refgo{model} are stored in the database using a database abstraction layer.

\struct{Slave}{
  A \reftype{Slave} models an instance of the \mamid slave application running on a host.
}{
  \property{Id}[uint]{Unique id.}
  \property{Hostname}[string]{Hostname of the host the slave is running on. \refproperty{Hostname} uniquely identifies a host in the cluster.} 
  \property{Port}[PortNumber]{Port on which the slave listens for connections from the master.}
  \property{MongodPortRangeBegin}[PortNumber]{Beginning of the range of ports \reftype{Mongod} spawned by the slave may listen on (inclusive).}
  \property{MongodPortRangeEnd}[PortNumber]{End of the range of ports \reftype{Mongod} spawned by the slave may listen on (exclusive).
      Implicitly specifies --- in combination with \refproperty{MongodPortRangeBegin} ---
      how many concurrently running \reftype{Mongod}s can be spawned by a slave.}
  \property{PersistentStorage}[bool]{Flag indicating whether the slave's data directory is located on persistent or volatile storage.}
      %todo ref location where it is mentioned that a slave is spawned with root data directory as a flag
  \property{ConfiguredState}[\reftype{SlaveState}]{The state of the slave set by the user.}
  \property{RiskGroup}[\reftype{RiskGroup}]{The risk group the slave is a member of.}
  \property{Mongods}[[]\reftype{Mongod}]{The \reftype{Mongod}s that are running or should be running on this slave.}
}

\goenum{SlaveState}
{}
{
  \goenumitem{Active}{Slaves in active mode are available to host Mongod instances. They are monitored and the administrator is notified of problems on the slave.}
  \goenumitem{Maintenance}{Slaves in maintenance mode are not monitored but running Mongods will not be stopped.}
  \goenumitem{Disabled}{
    Slaves in disabled mode are not monitored.
    The \refgo{master.ClusterAllocator} attempts to migrate Mongod instances from disabled slaves to active slaves.\\
    However, it will not violate or worsen availability constraints imposed by the administrator.
  }
}

\struct{RiskGroup}{
  A \reftype{RiskGroup} models a set of slaves sharing a common risk of failure.
  
  A \reftype{Slave} always belongs to exactly one \reftype{RiskGroup}.
  Hence, \codeinline{RiskGroup}s are mutually disjoint.
}{
  \property{Id}[uint]{Unique id.}
  \property{Name}[string]{Unique name of the risk group.}
  \property{Slaves}[[]\reftype{Slave}]{The \reftype{Slave}s that are members of a the given instance of \reftype{RiskGroup}.}
}

\struct{ReplicaSet}{
  A \reftype{ReplicaSet} models a MongoDB Replica Set consisting of multiple \reftype{Mongod}s.

  The degree of desired availbility \& redundancy of data stored in the Replica Set is modeled through 
  \refproperty{PersistentMemberCount} and \refproperty{VolatileMemberCount}.
}{
  \property{Id}[uint]{Unique id.}
  \property{Name}[string]{Name of the Replica Set.}
  \property{PersistentMemberCount}[uint]{Number of persistent \reftype{Mongod}s that should be part of this \reftype{ReplicaSet}.}
  \property{VolatileMemberCount}[uint]{Number of volatile \reftype{Mongod}s that should be part of this \reftype{ReplicaSet}.}
}

\struct{Mongod}{
  An instance of \reftype{Mongod} is uniquely identified by
  \begin{itemize}
    \item its parent slave (the machine it is running on)
    \item the port it is listening on
    \item the Replica Set it belongs to.
  \end{itemize}

  The two attributes \refproperty{DesiredState} and \refproperty{ObservedState} are both optional.

  The role of a Mongod process depends on the permutations of \codeinline{nil} and $\not=\codeinline{nil}$
    assignments and is depicted in the table below:
 
  \begin{figure}[H]
  \centering
  \begin{tabularx}{0.6\linewidth}{|c|X|X|}
          \hline
          \diaghead{lengthofthediagheads}{\codeinline{DesiredState}}{\codeinline{ObservedState}} & $=\codeinline{nil}$ & $\not= \codeinline{nil}$ \\\hline
          $=\codeinline{nil}$       & \text{not existent} & zombie  \\\hline
          $\not= \codeinline{nil}$  & not spawned & present \\\hline
  \end{tabularx}
  \caption{Mongod role by \codeinline{DesiredState} \& \codeinline{ObservedState}}
  \end{figure}

}{
  \property{Port}[\reftype{PortNumber}]{TCP Port number the Mongod is listening on.}
  \property{ReplSetName}[string]{Name of the Mongods Replica Set. A Mongod is always in exactly one Replica Set.}
  \property{ObservationError}[error]{
    Latest error that occurred when attempting to update the \refproperty{ObservedState}.\\
    \codeinline{nil} if no error occurred on last attempt.
  }
  \property{LastEstablishStateError}[\refgo{msp.SlaveError}]{
    Latest error reported by the slave when attempting to establish the \refproperty{DesiredState}.\\
    \codeinline{nil} if no error occurred on last attempt.
  }
  \property{DesiredState}[\reftype{MongodState}]{State the Mongod should be in. \codeinline{nil} if no desired state has been set.}
  \property{ObservedState}[\reftype{MongodState}]{State the Mongod was last observed to be in. \codeinline{nil} if no observation has been made.}
  \property{ParentSlave}[\reftype{Slave}]{Slave this Mongod is or should be running on}
}

\struct{MongodState}{
        Description of state of a particular \reftype{Mongod} that is not already contained in \refgo{model.Mongod}.
}{
  \property{IsShardingConfigServer}[bool]{indicates whether the Mongod is configured as a Sharding config server.}
  \property{ExecutionState}[MongodExecutionState]{execution state of the Mongod process.}
  \property{ReplicaSetMembers}[HostPort]{Replica Set members as reported by the Mongod process.}
}


\goenum{MongodExecutionState}{
  The different states of a Mongod that are relevant to the implementation of \mamid.

  The following value definitions are ordered by availibility of data in the particular state.
}{
  \goenumitem{Destroyed}{Mongod data directory not present and Mongod not running.}
  \goenumitem{NotRunning}{Data directory present but not Mongod running.}
  \goenumitem{Recovering}{Mongod running but not available for reads because data needs to be synced from other Replica Set members.
                          Common when adding new members to an existing Replica Set.}
  \goenumitem{Running}{Mongod running and in sync with other Replica Set members. }
}

\struct{HostPort}{
  Tuple of $(hostname, port)$ that is a Mongod's identifier for Replica Set members.
}{
  \property{Hostname}[string]{
    The hostname of the Replica Set member.\\
    For a given \codeinline{Hostname} a \refgo{model.Slave} with the same \codeinline{Hostname} should exist.\\
    Otherwise, there exists a Mongod in the cluster that is not managed by \mamid.
  }
  \property{Port}[PortNumber]{
    The port on the host identified by \refproperty{Hostname} on which theReplica Set member is listening.
  }
}

\typealias{PortNumber}[uint16]{
  A TCP port number as specified in \href{https://tools.ietf.org/html/rfc793\#section-3.1}{RFC 793 Section 3.1}.
}

\struct{Problem}{
  Representation of a problem or error that occurred during operation of the \refgo{master}.

  The references to \reftype{Slave}, \reftype{ReplicaSet} and \reftype{Mongod} enable searchability
  of the \reftype{Problem} list.
  If all references are \codeinline{nil}, the problem is still legitimate and should be reported by a user interface or alerting system.

  See \refgo{master.ProblemManager} for the transformation from errors to this structure.
}{
  \property{Id}[uint]{
    Unique ID of the problem. If the \emph{same} problem occurrs after it was resolved before,
    its different incarnations are distinguishable by their \refproperty{Id}.
  }
  %TODO really necessary? problem is uniquely identified by (Slave, ReplicaSet, Mongod)
  \property{Description}[string]{Short human-readable description of the problem, suitable for subject lines of error messages.}
  \property{LongDescription}[string]{Long human-readable description of the problem.}
  \property{ProblemType}[uint]{Identifies the \codeinline{StatusMessage} type this problem originated from. Used to check if a problem of the same type for the same \codeinline{ReplicaSet}/\codeinline{Slave}/\codeinline{Mongod} already exists.}
  \property{FirstOccurred}[time.Time]{The point in time when the particular problem first occurred.}
  \property{LastUpdated}[time.Time]{The point in time when the particular problem was last observed, e.g. the time of the last monitor run.}
  \property{Slave}[*Slave]{A reference to a \reftype{Slave} from which the problem originated. May be \codeinline{nil}}
  \property{ReplicaSet}[*\reftype{ReplicaSet}]{A reference to a \reftype{ReplicaSet} form which the problem originated. May be \codeinline{nil}}
  \property{Mongod}[*Mongod]{A reference to a \reftype{Mongod} from where the problem originated. May be \codeinline{nil}}
}

%data transfer objects (used to communicate via the master.Bus)

\struct{DesiredReplicaSetConstraintStatus}
{
  Represents whether the \refgo{master.ClusterAllocator} can satisfy the constraints on a Replica Set given by
  \begin{itemize}
    \item the persistent and volatile member counts of the \reftype{ReplicaSet}
    \item the maximum number of \reftype{Mongod}s on the \reftype{Slave}s
    \item the \reftype{RiskGroup}s
  \end{itemize}
}{
  \property{Unsatisfied}[bool]{Whether the constraint cannot be satisfied.}
  \property{ReplicaSet}[\reftype{ReplicaSet}]{The Replica Set whose constraints can/cannot be fulfilled}
  \property{ActualVolatileCount}[uint]{The count of volatile members the Replica Set now has because the constraints are not fulfilled. If they are fullfilled this is the same as \reftype{ReplicaSet.VolatileMemberCount}.}
  \property{ActualPersistentCount}[uint]{The count of persistent members the Replica Set now has because the constraints are not fulfilled. If they are fullfilled this is the same as \reftype{ReplicaSet.PersistentMemberCount}.}
}

\struct{MongodMatchStatus}
{
  Represents whether the observed and desired state of a \reftype{Mongod} do not match.
}{
  \property{Mismatch}[bool]{Whether the stated do not match.}
  \property{Mongod}[\reftype{Mongod}]{The Mongod whose states do/do not match}
}

\struct{ConnectionStatus}
{
  Represents whether a \reftype{Slave} cannot be reached from the master.
}{
  \property{Mismatch}[bool]{Whether the slave cannot be reached.}
  \property{Slave}[\reftype{Mongod}]{The slave that can/cannot be reached}
  \property{CommunicationError}[\refgo{msp.CommunicationError}]{The error that occurred when trying to reach the slave. \codeinline{nil} if slave can be reached}
}

\struct{ObservedReplicaSetConstraintStatus}
{
  Represents whether the observed member counts of a \reftype{ReplicaSet} do not match \reftype{ReplicaSet.VolatileMemberCount} and \reftype{ReplicaSet.PersistentMemberCount}
}{
  \property{Unsatisfied}[bool]{Whether the counts do not match.}
  \property{ReplicaSet}[\reftype{ReplicaSet}]{The Replica Set whose counts do not match.}
  \property{ActualVolatileCount}[uint]{The observed volatile member count of the Replica Set.}
  \property{ActualPersistentCount}[uint]{The observed persistent member count of the Replica Set.}
}


\section{Master: Main Package}
\beginpackage{master}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{master_classes}
	\caption{Master}
\end{figure}

The Master (\refgo{master}) is the most complex component of \mamid.

It fulfills many different tasks, running in separate goroutines.

These tasks need to communicate with each other. Two different mechanism are employed to achieve this:
\begin{itemize}
	\item A shared persistent database with an ORM abstraction layer
	\item A \reftype{Bus} that leverages Go's channels to send status updates
\end{itemize}
This results in loose coupling of the \refgo{master} components and increases maintainability of the code base.

\struct{Bus}{
	The \reftype{Bus} is used by the different components of the master to share and react to status updates.
	At the start of the application channels for all the components are created and passed into the components.
	The components can then use this channel to broadcast messages to the other components and receive messages
	from the Bus from which they can filter the ones they are interested in.
	
	All messages sent over the bus carry the current state --- not state changes --- and are
	sent repeatedly (i.e. level processing, not edge processing).
	
	\begin{figure}[H]
		\includegraphics[width=\textwidth]{activity_diagram}
		\caption{Communication inside the master over the Bus}
	\end{figure}
}{
	\property{channels}[[]chan interface\{\}]{The channels the Bus will broadcast the messages to.}
}{
	\method{GetNewChannel}[chan interface\{\}]{Creates a new channel that is attached to the Bus.
		The new channel will be added to \refproperty{channels} and returned to the caller}
}

\struct{Deployer}{
	The \reftype{Deployer} listens on the bus for \refgo{model.MongodMatchStatus} objects with \refgoalt{model.MongodMatchStatus.Mismatch}{Mismatch} set to true and deployes the desired state of the affected Mongod using the \refgo{msp.Client}
}{
	\property{DB}[gorm.DB]{Initialized handle to the database.}
	\property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.}
}{
	\method{Run}{Waits for \refgo{model.MongodMatchStatus} objects and runs \refmethod{pushMongodState} when a mismatch occurrs.}
	\method{pushMongodState}
	(
		\param{mongod}[model.Mongod]{The Mongod to push the state to.}
	){
		Gets the desired state of \refparam{mongod} from the database and pushes it using the \refgo{msp.Client}.
	}
}

\struct{Monitor}{
	The \reftype{Monitor} uses the \refgo{msp.Client} to query all slaves for their Mongod's states, saves the observed state in the database and compares the observed state to the desired state from the database. It publishes \refgo{model.MongodMatchStatus} objects with the result of each comparison on the bus.
}{
	\property{DB}[gorm.DB]{Initialized handle to the database.}
	\property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.}
}{
	\method{Run}{Periodically fetches the Mongods' states from the slaves, saves it in the database, compares it to the desired state using \refmethod{compareStates} and publishes the result on the bus as a \refgo{model.MongodMatchStatus} object.}
	\method{compareStates}[MongodMatchStatus]
	(
		\param{mongod}[model.Mongod]{The Mongod to compare the state of}
	){
		Compares the \refgo{model.Mongod.ObservedState} and \refgo{model.Mongod.DesiredState} for mismatches and returns the result as a \refgo{model.MongodMatchStatus}.
	}
}

\struct{ProblemManager}{
	The \reftype{ProblemManager} listens on the bus for \refgo{model.StatusMessage}s, checks if they represent an error and generates or removes a problem and saves the changes in the database.
}{
	\property{DB}[gorm.DB]{Initialized handle to the database.}
	\property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.}
}{
	\method{Run}{Listens for \refgo{model.StatusMessage}s on the bus and checks if they respresent an error.
		If they do, generates a problem using \refmethod{generateProblem} and stores it in the database.
		It they don't, checks if the database contains a problem of the same type for the same object and removes it.}
	\method{generateProblem}[Problem]
	(
		\param{e}[StatusMessage]{}
	){
		
	}
}

\struct{ClusterAllocator}{
  The \reftype{ClusterAllocator} determines the layout of the cluster managed by \mamid.

  It attempts to fulfill the constraints defined through the model objects, in particular
  \begin{itemize}
    \item A \refgo{model.ReplicaSet}'s \refgoalt{model.ReplicaSet.VolatileMemberCount}{VolatileMemberCount} \& \refgoalt{model.ReplicaSet.PersistentMemberCount}{PersistentMemberCount}
    \item The \refgo{model.Slave}'s allowed number of Mongod instances
          (\refgoalt{model.Slave.MongodPortRangeBegin}{MongodPortRangeBegin} to \refgoalt{model.Slave.MongodPortRangeEnd}{MongodPortRangeEnd}).
    \item The \refgo{model.Slave.ConfiguredState}
    \item The configured \refgo{model.RiskGroup}s.
  \end{itemize}

  An iterative algorithm is employed to decide on a cluster layout described through
  \refgo{model.Mongod.DesiredState}s that
  \begin{itemize}
    \item attempts to fulfill the above constraints
    \item attempts an even distribution of Mongods on the different cluster hosts
    \item is a minimal change in comparison to the previous layout
  \end{itemize}

  \begin{theorem}[Idempotence of the ClusterAllocator]
    \label{theorem:idempotence_clusterallocator}
    Let $l$ be a layout of the cluster. Then
          \[\text{ClusterAllocator}(\text{ClusterAllocator}(l)) =\text{ ClusterAllocator}(l)\].
  \end{theorem}

}{
  \property{DB}[gorm.DB]{Initialized handle to the database.}
  \property{BusChannel}[chan interface\{\}]{Initialized channel to the application bus.} %TODO ref}
}{
  \method{LayoutCluster}{Lay out the cluster as described above.}
}

\subsubsection{Pseudocode}

The \refgo{master.ClusterAllocator} is crucial to the stable operation of the \mamid-managed cluster.\\
Hence, it is worth defining the implementation of \refgo{master.ClusterAllocator.LayoutCluster} through pseudocode. %TODO parentheses

While studying the algorithms below, the reader should keep in mind that
\begin{itemize}
  \item changes in the cluster layout $\equiv$ change or creation of \refgo{model.Mongod.DesiredState} 
  \item the \refgo{model.Mongod.ObservedState} may change after an arbitrary amount of time or even not at all
  \item changes to a ReplicaSet must not violate or further worsen the high-availibility constraints,
        in particular \refgo{model.ReplicaSet}'s \refgoalt{model.ReplicaSet.VolatileMemberCount}{VolatileMemberCount} \& \refgoalt{model.ReplicaSet.PersistentMemberCount}{PersistentMemberCount}\\
        $\implies$ Mongods in \refgo{model.MongodExecutionState.Recovering} are an important special-case.
\end{itemize}

\input{master_pseudocode_clusterallocator}
