\section{Slave}
\renewcommand{\gocurpackage}{slave}

The \refgo{slave} is installed on the individual host nodes and started by the main service manager of the operating system during the boot process.

\subsection{Application / main()}{
  A Go application starts by initializing the Go 'main' package and then running the \textit{main()} function.
  This function performs early initialization of the slave's main datastructures:
  \begin{itemize}
    \item Parse command line flags using an external CLIFlagsParser.
    \item Initialize the MSPListener.
    \item Initialize the Controller with the MSPListener instance.
    \item Transfer control to MSPListener to wait for incoming connections.
  \end{itemize}
}

\struct{Controller}{
  Handles MSP requests by implementing the MSPConsumer interface. %TODO ref
  Hence, it coordinates the work required to fulfill requests from the master.
  Most importantly, it leverages ProcessManager and MongodConfigurator to spawn and configure instances of MongoDB.
}{
    \property{BusyTable}[map[PortNumber]bool]{
    Contains a boolean busy state per instance of MongoDB to prevent concurrent configuration of a single instance.
  }
  \property{busyTableLock}[sync.Mutex]{
    Mutex controlling access to busyTable. %TODO ref
  }
}

\struct{ProcessManager}{
  Starts processes, may provide a list of alive processes and eventually kill these.
}{
  \property{runningProcesses}[map[PortNumber]*exec.Cmd]{
    Holds the active process controls per instance
  }
}{
  \method{spawnProcess}[error](
    \param{m}[MSP.MongoD]{Mongod information about what exactly to spawn}
    \param{dataDir}[string]{Root directory of MongoDB data}
  ){
    Spawns a Mongod process as requested by the given Mongod inside the data root directory
  }
  \method{runningProcesses}[[]PortNumber]{
    Returns the PortNumbers of the currently running processes
  }
  \method{killProcess}[error](
    \param{p}[PortNumber]{PortNumber to identify process}
  ){
    Kills process by given PortNumber. Does not error if the process is already dead, only if it could not be killed.
  }
  \method{killProcesses}[error]{
    Kills all remaining Processes. Errors if it could not kill some processes.
  }
}

\interface{MongodConfigurator}{
  Applies or returns configuration of a mongod instance by PortNumber.
}{
  \method{MongodConfiguration}[{(MSP.MongodConfiguration, error)}](
    \param{p}[PortNumber]{PortNumber to connect to locally}
  ){
    Reads configuration from a local MongoDB instance
  }
  \method{ApplyMongodConfiguration}[error](
    \param{p}[PortNumber]{PortNumber to connect to locally}
    \param{c}[MSP.MongodConfiguration]{Configuration to apply}
  ){
    Connects to a local MongoDB instance on the given port and applies the configuration
  }
}

\struct{ConcreteMongodConfigurator}{
  Implements MongodConfigurator interface and uses an external MongoDB client to communicate with local instances
}