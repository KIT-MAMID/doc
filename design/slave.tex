\section{Slave}
\beginpackage{slave}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{slave_classes}
	\caption{Slave}
\end{figure}

The \refgo{slave} is installed on the individual host nodes and started by the main service manager of the operating system during the boot process.

\subsection{Application / main()}{
  A Go application starts by initializing the Go 'main' package and then running the \textit{main()} function.
  This function performs early initialization of the slave's main datastructures:
  \begin{itemize}
    \item Parse command line flags using an external CLIFlagsParser.
    \item Initialize the MSPListener.
    \item Initialize the Controller with the MSPListener instance.
    \item Transfer control to MSPListener to wait for incoming connections.
  \end{itemize}
}

\struct{Controller}{
  Handles MSP requests by implementing the \refgo{msp.Consumer} interface.
  Hence, it coordinates the work required to fulfill requests from the master.
  Most importantly, it leverages the \reftype{ProcessManager} and \reftype{MongodConfigurator} to spawn and configure instances of MongoDB.
}{
  \property{BusyTable}[map[\refgo{msp.PortNumber}]bool]{
    Contains a boolean busy state per instance of MongoDB.\\
    \refproperty{BusyTable} must only be altered from a goroutine holding the \refproperty{busyTableLock}.\\
    \vspace{-0.4em}\\ % dirty hack because we do not support paragraphs in property descriptions
    \refgo{msp.Consumer.EstablishMongodState} may be called repeatedly by \refgo{master}
    while an earlier state establishment request is still executing.\\
    However, a MongoDB instance must not be configured concurrently.\\
    Hence, \refproperty{BusyTable} in combination with \refproperty{busyTableLock} is used to ensure sequential configuration.
  }
  \property{busyTableLock}[sync.Mutex]{
    Mutex controlling access to \refproperty{BusyTable}.
  }
}

\struct{ProcessManager}{
  Starts processes, may provide a list of alive processes and eventually kill these.
}{
  \property{runningProcesses}[map[\refgo{msp.PortNumber}]*exec.Cmd]{Holds the active process controls per instance}
}{
  \method{spawnProcess}[*\refgo{msp.SlaveError}](
    \param{m}[\refgo{msp.Mongod}]{Mongod information about what exactly to spawn}
    \param{dataDir}[string]{Root directory of MongoDB data}
  ){
    Spawns a Mongod process as requested by the given Mongod inside the data root directory
  }
  \method{runningProcesses}[[]\refgo{msp.PortNumber}]{
    Returns the PortNumbers of the currently running processes
  }
  \method{killProcess}[*\refgo{msp.SlaveError}](
    \param{p}[\refgo{msp.PortNumber}]{PortNumber to identify process}
  ){
    Kills process by given \refgo{msp.PortNumber}. Does not error if the process is already dead, only if it could not be killed.
  }
  \method{killProcesses}[*\refgo{msp.SlaveError}]{
    Kills all remaining Processes. Errors if it could not kill some processes.
  }
}

\interface{MongodConfigurator}{
  Applies or returns configuration of a mongod instance by PortNumber.
}{
  \method{MongodConfiguration}[{(\refgo{msp.Mongod}, \refgo{msp.SlaveError})}](
    \param{p}[\refgo{msp.PortNumber}]{PortNumber to connect to locally}
  ){
    Reads configuration from a local MongoDB instance
  }
  \method{ApplyMongodConfiguration}[*\refgo{msp.SlaveError}](
    \param{config}[\refgo{msp.Mongod}]{Configuration to apply}
  ){
    Connects to the local MongoDB instance given in \refparam{config} parameter and applies the configuration
  }
}

\struct{ConcreteMongodConfigurator}{
  Implements MongodConfigurator interface and uses an external MongoDB client to communicate with local instances
}