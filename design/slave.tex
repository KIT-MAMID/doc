\section{Slave}
The slave is installed on the individual host nodes and started by the main service manager of the operating system during the boot process.

\subsection{Application / main()}{
  A Go application starts by initializing the Go 'main' package and then running the \textit{main()} function.
  This function performs early initialization of the slave's main datastructures:
  \begin{itemize}
    \item Parse command line flags using an external CLIFlagsParser.
    \item Initialize the MSPListener.
    \item Initialize the Controller with the MSPListener instance.
    \item Transfer control to MSPListener to wait for incoming connections.
  \end{itemize}
}

\struct{MSPListener}{
  Structure for handling communication through the MasterSlaveProtocol.
}{
  \property{consumer}{MSPConsumer}{
    Instance of a consumer, typically the Controller in a normal run
  }
}{
  \method{run}{
    Responsible for guaranteeing general communication, precisely:
    \begin{itemize}
      \item Waiting for a master to connect
      \item Sending and receiving data on the socket
      \item Dispatching incoming requests to the MSPConsumer
    \end{itemize}
  }
}

\interface{MSPConsumer}{
  This interface must be implemented by every structure wishing to consume updates from the MasterSlaveProtocol
}{
  \method{mspStatusRequest}[SlaveStatus]{
    Called when the master asked for an overview of all slaves. 
  }
  \method{mspEstablishMongodState}[error](
    \param{MSP.Mongod}{State to establish}
  ){
    Called when the master provided a Mongod instance and wishes its state to be applied as is. May return an error to be communicated back to the master. 
  }
}

\struct{Controller}{
  Implements the MSPConsumer interface. Communicates with the ProcessManager and MongodConfigurator in order to fulfill requests.
}{
  \property{busyTable}{map[PortNumber]bool}{
    Contains a boolean busy state per instance in order to prevent conflicts
  }
  \property{busyTableLock}{sync.Mutex}{
    Mutex controlling access to busyTable
  }
}

\struct{ProcessManager}{
  Starts processes, may provide a list of alive processes and eventually kill these.
}{
  \property{runningProcesses}{map[PortNumber]exec.Cmd}{
    Holds the active process controls per instance
  }
}{
  \method{spawnProcess}[error](
    \param{MSP.MongoD}{Mongod information about what exactly to spawn}
    \param{string}<dataDir>{Root directory of MongoDB data}
  ){
    Spawns a Mongod process as requested by the given Mongod inside the data root directory
  }
  \method{runningProcesses}[[]PortNumber]{
    Returns the PortNumbers of the currently running processes
  }
  \method{killProcess}[error](
    \param{PortNumber}{PortNumber to identify process}
  ){
    Kills process by given PortNumber. Does not error if the process is already dead, only if it could not be killed.
  }
  \method{killProcesses}[error]{
    Kills all remaining Processes. Errors if it could not kill some processes.
  }
}

\interface{MongodConfigurator}{
  Applies or returns configuration of a mongod instance by PortNumber.
}{
  \method{MongodConfiguration}[{(MSP.MongodConfiguration, error)}](
    \param{PortNumber}{PortNumber to connect to locally}
  ){
    Reads configuration from a local MongoDB instance
  }
  \method{ApplyMongodConfiguration}[error](
    \param{PortNumber}{PortNumber to connect to locally}
    \param{MSP.MongodConfiguration}{Configuration to apply}
  ){
    Connects to a local MongoDB instance on the given port and applies the configuration
  }
}

\struct{ConcreteMongodConfigurator}{
  Implements MongodConfigurator interface and uses an external MongoDB client to communicate with local instances
}