\documentclass[11pt,aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usetheme{default}
\usepackage{pdfpcnotes}
\usepackage{todonotes}
\usepackage{xspace}
%checkmarks
\usepackage{pifont}
\newcommand{\xmark}{\ding{55}}%

% MAMID macro
\newcommand{\mamid}{\textit{MAMID}\xspace}

%done checkmark
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\newcommand{\checkcomment}[1]{
    \def\temp{#1}
    \ifx\temp\empty
    \emph{}
    \else
    \emph{Note: #1}
    \fi
}
\newcommand{\done}[1][]{{\color{darkgreen}\checkmark\checkcomment{#1}}}
\newcommand{\notdone}[1][]{{\color{red}\xmark\checkcomment{#1}}}


% insert section title at \section{}
% http://tex.stackexchange.com/questions/178800/creating-sections-each-with-title-pages-in-beamers-slides
\AtBeginSection[]{
    \begin{frame}
        \vfill
        \centering
        \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
            \usebeamerfont{title}\insertsectionhead\par%
        \end{beamercolorbox}
        \vfill
    \end{frame}
}

\begin{document}
   	\author{Niklas Fuhrberg, Anton Schirg,\\ Christian Schwarz, Janis Streib, Bob Weinand}
    \title{MAMID}
    \subtitle{Monitor and Manager for In-memory Databases}
    %\logo{}
    \institute{\textbf{Supervisor}\\Dr Marek Szuba\\SCC}
    \date{8 June 2016}
    \subject{Final Presentation}
    %\setbeamercovered{transparent}
    %\setbeamertemplate{navigation symbols}{}
    
    \frame[plain]{\maketitle}

    \begin{frame}[label=waterfall]{PSE: Where are we?}
        \centering\huge
        \textbf{5-stages image of the waterfall model}
    \end{frame}
    
    \section{Requirements Elicitation}
    
    \begin{frame}{Motivation}
        \begin{itemize}
            \item Envisat earth observation satellite
            \item Archive of data from MIPAS instrument\pnote{MIPAS records trace gasses in the atmosphere}
            \item Research project at IMK: %TODO what is its name?
            \item \pnote{Original data not that big but }Processed data: $96+$ TB
            \item Periodic reprocessing \& archiving \pnote{Reprocessing happens periodically, old results need to be kept for reference purposes => dataset is growing}
            \item Use MongoDB for storage\pnote{use MongoDB's sharding feature (more in a second) to distribute the data over multiple machines, easy way to access data and use it in downstream applications}
        \end{itemize}
    \end{frame}
    
    \begin{frame}{MongoDB}
        TODO
        \begin{itemize}
            \item MongoDs / Mongods
            \item Replica Set
            \item Sharding
        \end{itemize}
    \end{frame}
    
    \begin{frame}[allowframebreaks]{MongoDB on IMK Cluster}
        
        \begin{figure}
            \centering
            \missingfigure[figwidth=0.8\linewidth]{PSU image, no replica sets or risk groups}
        \end{figure}

        \begin{itemize}
            \item Few big machines with (slow?) persistent storage\\%TODO ask marek whcih one it is
                  + 4 cabinets à 20 blades à $98$ GB RAM %TODO check this
            \item Runs OpenIndiana \pnote{openindiana, who has heard of it? it's an illumos distro. which is? anyone??}
            \item Blades have small boot-only HDDs
            \item Cabinets have independent PSUs
        \end{itemize}

        \framebreak
        
        Performance: Replica Sets \pnote{so what can we do to maximize performance, in particular read performance for downstream applications?}
        
        \begin{itemize}
            \item Primaries: on blades with in-memory storage (\emph{performance})
            \item Secondaries: on machines with HDDs (\emph{persistence}) \pnote{this can be arranged by configuring the Priority of a Mongod in Replica Set elections}
        \end{itemize}
        \pnote{indicate where primaries and secondaries go using a pointing device}
        \begin{figure}
            \centering
            \missingfigure[figwidth=0.8\linewidth]{PSU image, replica sets, each replica set only on one PSU. Second version: failure of one PSU kills one replset}
        \end{figure}
        
        \framebreak
        
        Availability \& Redundancy: Risk Groups \pnote{so far we have performance, but what happens in case a PSU dies and takes a cabinet offline?}
        
        \begin{itemize}
            \item Distribute Replica Set members over different cabinets
            \item Assert enough Replica Set members have persistent storage\pnote{requirements may vary, depending on importance of data, ... generally a tradeoff between space usage and safety}
        \end{itemize}
        
        \begin{figure}
            \centering
            \missingfigure[figwidth=0.8\linewidth]{PSU image, replica sets, risk groups marked, each replica set distributed}
        \end{figure}
        
        \framebreak
        
        Operation
        
        \begin{itemize}
           \item Monitor Mongod processes \& configuration
           \item Notify administrators
           \item Continuous redeployment\pnote{blades may fail and loose their state \& data(remember: they are in-memory only)}
           \item Self-healing using hot spares\footnote{not in current release though (time constraints)}\pnote{Idea: have unused machines available to replace failing ones.}
        \end{itemize}
        
    \end{frame}
    
    \section{Related Work}
    
    \begin{frame}{Related Work}
        
        \begin{itemize}
            \item MongoDB In-Memory Engine ($<$ 3.2.6, \textit{enterprise} subscription)
            \item MongoDB Ops Manager (\textit{enterprise} subscription)
            \item MongoDB Cloud Manager (\textit{enterprise} subscription)
            \item Configuration Management (Puppet, etc.): cannot model dependencies, no monitoring, no integrated solution
        \end{itemize}
        
        Problems
        
        \begin{itemize}
            \item No MongoDB \textit{enterprise} binaries for OpenIndiana
            \item No solution to the mix of persistent \& volatile storage 
        \end{itemize}
        \pnote{regex matching host names appears to be possible, adequately named host schema would probably work out ok}
        
    \end{frame}
    
   \againframe<2>{waterfall}
    
    \section{Requirements Analysis}
   
   \begin{frame}<1-10>[label=reqanalysis]{Requirements Analysis}
       
        \begin{columns}
        \begin{column}{0.5\linewidth}
            Features
            \begin{itemize}
                \item<2-> declarative administration \only<11->{\done}
                \item<3-> simple graphical interface \only<12->{\done}
                \item<4-> automation! \only<13->{\done}
                \begin{itemize}
                    \item<5-> cluster layout \only<13->{\done}
                    \item<6-> persistence requirements \only<13->{\done}
                    \item<7-> deployment \only<13->{\done}
                    \item<8-> reconfiguration \only<13->{\done}
                \end{itemize}
                \item<9-> monitoring \only<14->{\done}
                \item<10-> alerting \only<15->{\done}
            \end{itemize}
        \end{column} 
       	\begin{column}{0.5\linewidth}
            \onslide<16->{Demarcation Criteria}
            \begin{itemize}
                \item<17-> no manual configuration
                \item<18-> limited to MongoDB\pnote{originally, extensibility to other databases was considered}
                \item<19-> no Sharding query router deployment (\textit{mongos}) \pnote{we provide useful help for this, however}
            \end{itemize}
            \vspace{6em} % dirty hacks
        \end{column}
        \end{columns}
    \end{frame}
    
    \begin{frame}{Declarative Administration}
        
        \begin{itemize}
           \item<1-> Administrator describes cluster topology
               \begin{description}
                   \item[Slaves] hosts in the cluster
                   \item[Risk Groups] shared risk of failure, e.g. cabinets
                   \item[Replica Sets] persistent \& volatile member count, configuration parameters
                \end{description}
           \item<2-> $\equiv$ set of constraints
           \item<3-> allocation algorithm: \alert<3>{greedy}, \alert<4>{priority driven}, \alert<5>{idempotent}
        \end{itemize}
       
        
    \end{frame}
    
    
    \begin{frame}[allowframebreaks]{Declarative Administration: Screenshots}
         \missingfigure[figwidth=\linewidth]{screenshot slave CREATION view (no slave states)}
         \framebreak
         \missingfigure[figwidth=\linewidth]{screenshot risk group view with lots of configured slaves \& risk groups}
         \framebreak
         \missingfigure[figwidth=\linewidth]{screenshot replica set creation view}
         \framebreak
         \missingfigure[figwidth=\linewidth]{screenshot replica set view, with all Mongods active}
    \end{frame}
    
    \begin{frame}{Controlling Deployment}
        \begin{columns}
            \begin{column}{0.6\linewidth}
                \begin{itemize}
                    \item \textbf{Slave states} control allocation of Mongods
                    \begin{description}
                        \item[active] can host Mongods \pnote{slave will be used to satisfy replica set constratins, if in the right risk group}
                        \item[maintenance] scheduled downtime, no redeployment\pnote{use case: rebooting for system updates}
                        \item[disabled] should not host Mongods\pnote{slave not used to satisfy replica set constraints. use case: machine shall be removed from the cluster, be used as hot spare, etc.}
                    \end{description}
                    \item Migration of Mongods without reduced redundancy\pnote{example: setting a Slave to disabled that is the only persistent host in a Replica Set is probably a bad idea...}
                \end{itemize}
            \end{column}
            \begin{column}{0.4\linewidth}
                \missingfigure[figwidth=\linewidth]{closeup of button states}
            \end{column}
        \end{columns}
        
    \end{frame}
    
     \begin{frame}[allowframebreaks]{Controlling Deployment: Screenshots} % this slide gives an impression on how to think when administering MAMID: manipulate constraints, not take direct actions
        \missingfigure[figwidth=\linewidth]{screenshot replica set view, one slave with problems}
        \framebreak
        \missingfigure[figwidth=\linewidth]{screenshot slave view of slave with problems, should be clear the slave has an error}
        \framebreak
        \missingfigure[figwidth=\linewidth]{screenshot slave view, right after desired state switched to Disabled (transitioning spinner visible)}
        \framebreak
        \missingfigure[figwidth=\linewidth]{screenshot slave view, replica set view: all green, maybe emphasizing circle around new (replacement) slave}
        \framebreak
    \end{frame}
    
    \againframe<10-15>{reqanalysis}
    
    \begin{frame}{Monitoring \& Alerting}
        \begin{itemize}
            \item declarative administration $\implies$ infrastructure description
            \item zero-configuration monitoring \pnote{emphasize it is built in}
            \item HTTP API: decouple monitoring \& alerting \pnote{expose recognized problems through an HTTP API}
            \begin{itemize}
                \item MAMID \textit{notifier} supports e-mail notifications
                \item easy integration into existing infrastructure possible \pnote{HTTP API also allows easy integration into existing monitoring frameworks \& alerting services, e.g. Pager Duty, Pushover or similar}
            \end{itemize}
        \end{itemize}
    \end{frame}
    
   \againframe<15-19>{reqanalysis}
    
    \begin{frame}
        \frametitle{Implementation Constraints}
        \begin{itemize}
            \item<2-> Primary target OS: OpenIndiana 105a9
            \item<3-> Frontend: Web Frameworks TODO Janis %TODO
            \item<4-> Core Application: Go $>=$ 1.6
            \begin{itemize}
                \item<5-> compiled language, good performance
                \item<6-> built-in concurrency paradigm (channels)
                \item<7-> rich standard library
                \item<8-> cross-platform, simple cross-compilation \pnote{solves problem of missing C++ 11 support in the C++ compiler on the cluster}
                \item<9->\texttt{\$ GOOS=solaris go build}
            \end{itemize}
        \end{itemize}
        
    \end{frame}
        
   
     % end of requirement analysis
    
    
    
    
\end{document}


