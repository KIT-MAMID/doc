% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[fleqn]{amsmath} %left aligned equations
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{amssymb}
\usepackage{calc}
\usepackage{enumitem} 
\usepackage{url}
\usepackage{parskip}
% http://tex.stackexchange.com/questions/17730/newcommand-and-spacing
\usepackage{xspace}
% 'frame' option for figures
\usepackage[export]{adjustbox}
% fancy page headers
\usepackage{fancyhdr}
\usepackage{xcolor}

% page style
\pagestyle{fancy}
\fancyhead[R]{\includegraphics[width=2cm]{assets/kitlogo}}
\fancyhead[L]{\leftmark}
\fancypagestyle{plain}{
	\rhead{\includegraphics[width=2cm]{assets/kitlogo}}
	\lhead{\leftmark}
}

% TODO: template übersetzten

\makeglossaries

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{
  \glsdoifexists{#2}{
    \def\@glsnumberformat{glsgobblenumber}
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}
    \setkeys{glossadd}{#1}
    \@gls@saveentrycounter
    \@do@wrglossary{#2}
  }
}
\renewcommand{\glsaddallunused}[1][]{
  \edef\@glo@type{\@glo@types}
  \setkeys{glossadd}{#1}
  \forallglsentries[\@glo@type]{\@glo@entry}{
    \ifglsused{\@glo@entry}{}{
      \glsaddnp[#1]{\@glo@entry}}}
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

% usage: \counteditem{prefix}{refName} -> item `/prefixXX/` with label `prefix:refName` (where XX is counted in increments of 10)
\makeatletter
\newcommand{\oitem}[2]{
  % define the counter
  \@ifundefined{c@oitem#1}{\newcounter{oitem#1}}{} % initialized at 0
  \addtocounter{oitem#1}{10}
  \item[\namedlabel{#1:#2}{/#1\arabic{oitem#1}/}]
}
\makeatother

% usage: \testfall{szenario}{ablauf}{ergebnis} oder \testfall[\ref{F:getesteteFunktion}]{szenario}{ablauf}{ergebnis}
\newcommand{\testfall}[4][]{
  \begin{description}
    \ifthenelse{\equal{#1}{}}
               {} % optional argument #1 is empty: skip
               {\item[Testet] #1}
    \item[Vorbedingungen] #2
    \item[Ablauf] #3
    \item[Erwartetes Ergebnis] #4
  \end{description}
}

\newcommand{\testsequence}[3][]{
	\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries Preconditions}]
		\ifthenelse{\equal{#1}{}}
		{} % optional argument #1 is empty: skip
		{\item[Tests] #1}
		\item[Preconditions] #2
		\item[Steps] #3
	\end{description}
}

% new page after section
\let\oldsection\section
\renewcommand\section{\clearpage\oldsection}

\newcommand{\mamidscreenshot}[1]{\includegraphics[width=\textwidth,frame]{#1}}

\newcommand{\uiel}[3]{\item \textbf{"#1" #2:} #3}

\begin{document}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\mamid}{\textit{MAMID}\xspace}

\include{glossary}

\begin{titlepage}
\makeatletter
\begin{center}
~\\[4em]
{\Huge MAMID}\\[.8em]\huge{Monitor and Manager for In-Memory Databases}\\[2em]
{\huge Functional Specification}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Niklas Fuhrberg\\
Anton Schirg\\
Christian Schwarz\\
Janis Streib\\
Bob Weinand\\[3em]}
{\Large supervised by}\\[2em]
{\LARGE
Dr. Marek Szuba\\[1em]}
{\Large at}\\[1em]
{\LARGE
Karlsruhe Institute of Technology\\
SCC\\[2em]}
{\color{gray}
  \small Document Version: \input{.git/refs/heads/master}
}
\end{center}
\makeatother
\end{titlepage}
\newpage
\tableofcontents
\newpage

% -------------------------------------------------------------- HIER BEGINNT DAS DOKUMENT WIRKLICH ---------------------------------
\section{Introduction}
\mamid is a manager for database \glspl{cluster}, facilitating creation, administration and monitoring of a \gls{MongoDB} \gls{replica set} deployment.

\gls{MongoDB} is a document-oriented database application. \glslink{replica set}{Replica sets} are MongoDB's solution to data-redundancy and high-availability. Each replica set consists of multiple processes on different machines storing the same data.\\
After initial configuration, data replication is handled by MongoDB itself.

\mamid assists the \gls{administrator} during setup, continuous operation, maintenance situations and expansion of a \gls{MongoDB} cluster.

The \gls{administrator} describes the cluster \glspl{host} and the desired \gls{MongoDB} \glspl{replica set} to \mamid.
Limitations of individual hosts, e.g. absence of persistent storage, can be modeled.

Each \gls{host} runs a \gls{slave} application of \mamid, enabling control of the entire deployment from a single \gls{master} instance of \mamid.

\mamid utilizes the \gls{administrator}'s description of the cluster and replica sets to run \gls{MongoDB} instances on the \glspl{host}.\\
It configures the \gls{MongoDB} instances to form the desired replica sets, asserting that administrator-defined constraints regarding redundancy \& persistence of storage are met.

\mamid monitors the deployed configuration continuously and informs the \gls{administrator} about problems (when they arise).

Maintenance \& administrative action on individual hosts is announced to \mamid beforehand.\\
This information is used to silence alerts during downtime and to preemptively reconfigure MongoDB instances to avoid reduced redundancy \& performance.

A possible deployment of \mamid is depicted in Figure \ref{fig:cluster_layout}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9875\textwidth]{cluster_layout} % coefficient to keep this figure on the same page as the text.
	\caption{Possible cluster layout for a single application built on MongoDB}
	\label{fig:cluster_layout}
\end{figure}

\section{Objectives \& Criteria}
\subsection{Mandatory Criteria}\label{MandatoryCriteria}

\subsubsection{Cluster Description by Administrator}
% TODO analyze whether the given criteria can be phrased more abstractly \& move the details to (new) functional requirements. (-> forward lookup references from criteria to functional requirement if required)
\begin{description}

\oitem{MC}{} The \gls{administrator} interacts with \mamid through a web \acrshort{gui}.

% inventory ops
\oitem{MC}{inventory_definition} The \gls{master} maintains a list of \glspl{slave} called \gls{inventory}.
\begin{description}
\oitem{MC}{} The \acrshort{gui} visualizes the \gls{inventory}.
\oitem{MC}{} The \gls{administrator} can add \glspl{slave} to the \gls{inventory}.
\oitem{MC}{} The \gls{administrator} can remove a \gls{slave} that does not host any \gls{MongoDB} processes from the \gls{inventory}.
\oitem{MC}{spec_risk_groups} The \gls{administrator} can model a shared risk of failure between \glspl{host}, e.g. a shared power supply.
\oitem{MC}{available_slave_types} The \gls{administrator} can specify whether the \gls{slave} has \glslink{persistent storage}{persistent (typically HDD/SSD backed)} or \glslink{volatile storage}{volatile (RAM backed)} storage.
\oitem{MC}{root_data_directory} The \gls{administrator} can specify in which filesystem directory on the \gls{host} the \gls{slave} and its \gls{MongoDB} processes store data.
% inventory ops -> slave
\oitem{MC}{slave_mode_active} The \gls{administrator} can announce to \mamid that a slave is ready to host MongoDB processes.
\oitem{MC}{slave_mode_maintenance} The \gls{administrator} can announce to \mamid that a slave is in maintenance to inhibit automatic reconfiguration of its MongoDB processes.
\oitem{MC}{slave_mode_disabled} The \gls{administrator} can announce to \mamid that a slave should not host any MongoDB processes.
\end{description}

% replica set ops
\oitem{MC}{replica_set_create} The \gls{administrator} can describe a new \gls{MongoDB} \gls{replica set} by specifying constraints on how it should be configured by \mamid.
\begin{description}
\oitem{MC}{replica_set_config_profiles} The \gls{administrator} can --- on creation of a replica set (\ref{MC:replica_set_create}) --- specify that it must be usable as a configuration server for \gls{MongoDB} \gls{sharding}.
\oitem{MC}{replica_set_member_total_counts} The \gls{administrator} can select the number of \gls{MongoDB} instances (members) of a replica set.
\oitem{MC}{replica_set_member_pv_counts} Volatile and persistent member count of a \gls{replica set} can be independently configured, under constraints described in \ref{F:master_alloc_resp_pv_counts}.
\end{description}
\oitem{MC}{} The \acrshort{gui} visualizes the list of configured \glspl{replica set}.
\oitem{MC}{} The \gls{administrator} can destroy a \gls{replica set}.

\end{description}

\subsubsection{MongoDB Configuration \& Monitoring}
\begin{description}
\oitem{MC}{mongod_deployment1} \mamid asserts that the replica sets described by the administrator are configured on the cluster (see \ref{MC:replica_set_create}).
\oitem{MC}{mongod_deployment2} To achieve \ref{MC:mongod_deployment1}, \mamid spawns \& controls \gls{MongoDB} processes on the hosts using a \gls{slave} process.
\begin{description}
	\oitem{MC}{mongod_redeployment} \mamid redeploys configured \gls{MongoDB} processes to hosts where the \gls{slave} process reports a situation different from what is expected by the \gls{master}.
	\oitem{MC}{mongod_redeployment_powercycle_specific} Specifically, a host with volatile data storage can loose all data originating from the \gls{slave} process or \gls{MongoDB} and is automatically redeployed with correctly configured \gls{MongoDB} instances (\ref{MC:mongod_deployment2}).
\end{description}
% Todo old \oitem{MC}{} The \gls{master} deploys the \gls{replica set} configuration described by the administrator to the cluster.

% monitoring features
\oitem{MC}{detect_slave_unexpected_behavior} \mamid detects when a \gls{slave} in the \gls{inventory} behaves unexpectedly, e.g. when it becomes unreachable and the administrator did not announce maintenance to \mamid beforehand.
\oitem{MC}{} \mamid informs the \gls{administrator} by e-mail about problems in the cluster (\ref{MC:detect_slave_unexpected_behavior}).
\oitem{MC}{} The \acrshort{gui} visualizes \glspl{slave} behaving unexpectedly (\ref{MC:detect_slave_unexpected_behavior}).
\end{description}

\subsection{Optional Criteria}\label{OptionalCriteria}
\begin{description}
	
% master
\oitem{OC}{api_authentication} \mamid requires authentication from the user for all operations.
	
% inventory
\oitem{OC}{manual_autodiscovery} \mamid auto-discovers new \glspl{slave} on the \gls{administrator}'s request.
\oitem{OC}{continuous_autodiscovery} \mamid continuously auto-discovers new \glspl{slave}.
\oitem{OC}{monitor_icmp} \mamid recognizes when the \gls{slave} software does not respond but the corresponding \gls{host} is still connected to the network.
\oitem{OC}{export_import_snapshot} The \gls{administrator} can backup and restore the cluster description.

% slaves
\oitem{OC}{tweak_performance_parameters} The \gls{administrator} can customize performance-relevant parameters of \gls{MongoDB} processes.

% automatic repair
\oitem{OC}{auto_repair} \mamid supports automatic reconfiguration when detecting unexpected behavior of \glspl{slave}. The failing slave is marked as unsuitable to host \gls{MongoDB} processes and redeployment is triggered to repair the degraded replica sets (extends \ref{MC:detect_slave_unexpected_behavior}).

% replica sets
\oitem{OC}{deploy_arbiters} \mamid deploys \gls{MongoDB} \glspl{arbiter} for configured \glspl{replica set} as needed, removing the restriction to an odd count of replica set members in \ref{F:master_alloc_resp_pv_counts}.
\oitem{OC}{extended_monitoring} \mamid supports extended monitoring of hosts, i.e. metrics beyond the processes managed by \mamid.

% other
\oitem{OC}{} The \gls{administrator} can interact with \mamid via a \acrshort{cli}.
\oitem{OC}{http_api} The \gls{administrator} can interact with \mamid via a stable, documented \acrshort{HTTP} \acrshort{API}.
\end{description}

\subsection{Demarcation Criteria}
\begin{description}
\oitem{DMC}{} The \gls{administrator} does not directly configure individual \gls{MongoDB} instances spawned \& controlled by \mamid. All configuration happens through \mamid, either automatically (e.g. replica set deployment) or through a \mamid interface (e.g. GUI, CLI, HTTP API).
\oitem{DMC}{} \mamid does not implement support for higher-layer \gls{MongoDB} features, e.g. \gls{sharding}.
\oitem{DMC}{} \mamid neither deploys the operating system nor other required software (such as \gls{MongoDB} binaries) to the \gls{cluster} \glspl{host}.
\end{description}

\section{Product Usage}

\subsection{Scope of Application}
\begin{itemize}
\item \gls{MongoDB} \glslink{cluster}{Cluster} Administration
\item High-Availibility MongoDB Deployment
\item MongoDB Cluster Monitoring
\end{itemize}

\subsection{Target Users}
\begin{itemize}
\item Cluster \glspl{administrator} in charge of creating \& managing a MongoDB replica set deployment.
\end{itemize}

\subsection{Operating Conditions}
\begin{itemize}

\item Low maintenance capacity for the cluster (time, personnel)
\item Uncomplicated takeover by a successor must be possible (flat learning curve)
\end{itemize}

\section{Operational Environment}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{hardware_layout}
	\caption{Possible cluster hardware layout}
\end{figure}

\subsection{Software}\label{subsec:Software}
\begin{itemize}
\item Primary Target Operating System: Open Indiana Build 151a9 (Illumos Kernel, 64bit)
\begin{itemize}
	\item Secondary Target: All POSIX-compliant Operating Systems
\end{itemize}
\item MongoDB version 3.2 or newer
\end{itemize}

\subsection{Hardware}
Each of the subsequently listed requirements is an extension of the previous one.
\subsubsection{Cluster Hosts: Hardware}
\begin{itemize}
	\item 64bit amd64 Instruction Set
	\item Up to $1GB$ file storage for \mamid application binaries \& assets.
	\item Sufficient \glslink{persistent storage}{persistent} or \gls{volatile storage} to hold the required \gls{MongoDB} data. \\
	\begin{itemize}
		\item \textbf{Note}: fewer \glspl{host} with \gls{persistent storage} in the cluster may require more storage capacity \& \gls{MongoDB} instances per persistent host.
	\end{itemize}
\end{itemize}

\subsubsection{Cluster Hosts: Interconnect}
\begin{itemize}
	\item All hosts are interconnected through fast \acrshort{LAN}.
	\begin{itemize}
		\item All cluster hosts are interconnected through an isolated \acrshort{LAN}.
		\item $>= 1$ cluster host is connected to both the isolated \acrshort{LAN} and an external network (usually another \acrshort{LAN} or \acrshort{WAN}).
	\end{itemize}
\end{itemize}

\subsubsection{Operation of Persistently Stored Replica Sets}
\begin{itemize}
	\item $>= 1$ cluster host with \gls{persistent storage}
	\item $>= 3$ cluster hosts in total
\end{itemize}

\subsubsection{Basic Level of Host Redundancy}
\begin{itemize}
	\item $>= 3$ mutually disjoint sets of \gls{cluster} \glspl{host} that can be classified as not sharing a common risk of failure (see \ref{F:master_alloc_resp_risk_groups}).
\end{itemize}

\section{System Model}
\begin{figure}[H]
\includegraphics[width=\textwidth]{module_overview}
\caption{\mamid Modules Overview}
\end{figure}
\subsection{Master}\label{SM:Master}
\begin{description}
	\oitem{SM}{masterapiserver} Master::APIServer\\
	Provides an \acrshort{API} for \gls{cluster} status reporting and administrative activity. (\ref{F:master_api_crud_slaves}, \ref{F:master_api_crud_risk_groups}, \ref{F:master_api_set_slave_mode}, \ref{F:master_api_crud_repl_set_config}, \ref{F:master_api_error_reports}, \ref{OF:master_api_get_auto_discovered_slaves}, \ref{OF:master_api_machine_metrics}, \ref{OF:master_api_repl_set_status})
 	\oitem{SM}{} Master::Controller\\
	Controls flow of events between different \gls{master} submodules.\\
	Updates the inventory database (\ref{SM:inventory}) as state change is recognized by the monitor.\\
	Implements automatic administration as explained in \ref{OF:master_controller_auto_repair}.)
	\oitem{SM}{inventory} Master::Inventory\\
	Database containing
	\begin{itemize}
		\item list of \glspl{slave} and associated state
		\item list of configured \glspl{replica set}.
	\end{itemize}
	(see \ref{F:master_inventory_persist_conf_state} and section \ref{ProductData})
	\oitem{SM}{master_clusterallocator} Master::ClusterAllocator\\
	It lays out the \gls{cluster}, i.e. decides the distribution of mongod instances onto \gls{cluster} \glspl{host}. (\ref{F:layout_cluster_config})\\
	It respects constraints as described by \ref{F:master_alloc_resp_risk_groups}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode} and \ref{OF:master_alloc_arbiters}.\\
	It communicates with the \glspl{slave} using \ref{SM:masterslaveproto} to enforce the \gls{cluster} layout. (\ref{F:master_alloc_communicate_config})
	\oitem{SM}{master_monitor} Master::Monitor\\
	Is responsible for observing consistency of the deployment, i.e. checking whether the \hyperref[SM:master_clusterallocator]{ClusterAllocator}'s cluster layout is actually deployed \& running on all \glspl{slave} (\ref{F:master_monitor_config}, \ref{OF:master_monitor_icmp}, \ref{OF:master_monitor_continuous_auto_discovery}).
\end{description}
\subsection{MasterSlaveProtocol}\label{SM:MasterSlaveProtocol}
\begin{description}
	\oitem{SM}{masterslaveproto} MasterSlaveProtocol\\
	Is responsible for communication between \gls{master} and \gls{slave}. (\ref{F:msp_trans_config}, \ref{F:msp_trans_reachability}, \ref{OF:msp_trans_mach_metr}, \ref{OF:msp_trans_repl_status})
\end{description}
\subsection{Slave}\label{SM:Slave}
\begin{description}
	\oitem{SM}{} Slave::Controller\\
	Dispatches instructions to the \hyperref[SM:mongodbclient]{Slave::MongoDBClient} and \hyperref[SM:processmanager]{Slave::ProcessManager}. (\ref{F:slave_enforce_config})\\
	It notifies via \hyperref[SM:masterslaveproto]{MasterSlaveProtocol}
	\begin{itemize}
		\item whether operations failed or succeeded 
		\item as well as not locally recoverable failures.
	\end{itemize}
	(\ref{F:slave_report_config}, \ref{OF:slave_report_machine_metrics}, \ref{OF:slave_report_repl_status})
	\oitem{SM}{mongodbclient} Slave::MongoDBClient\\
	Implements communication with \gls{MongoDB} processes. (\ref{F:slave_communicate_with_mongodb})
	\oitem{SM}{processmanager} Slave::ProcessManager\\
	Spawns and controls \gls{MongoDB} processes. (\ref{F:slave_control_procs})
\end{description}
\subsubsection{Slave Modes}\label{SM:SlaveModes}
\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{state_diagram}
\caption{Slave State Diagram}
\end{figure}
The \hyperref[SM:Master]{Master} tracks a slave's state which affects error reporting \& cluster layout in the master.

A slave can be in the following states:
\begin{itemize}
	\item \glslink{active mode}{active}\\
	\mamid monitors \glspl{slave} in active mode. \glslink{slave}{Slaves} in this mode behave as expected, i.e. are running MongoDB processes in the configuration determined by the \hyperref[SM:Master]{Master}.\\
	If the slave behaves unexpectedly, e.g. is not reachable, \mamid notifies the \gls{administrator} and sets the slave's state to \emph{unknown}.
	\item \emph{unknown}\\
	\mamid monitors \glspl{slave} in \emph{unknown} state and sets them back to \gls{active mode} when they recover.\\
	\mamid can recover a slave in \emph{unknown} state automatically by respawning and configuring MongoDB processes, e.g. after power-loss on a \glslink{volatile storage}{volatile} \gls{host}.
	The \gls{administrator} can set the slave state
	\begin{itemize}
		\item to \gls{maintenance mode} to stop monitoring of the slave or
		\item to \gls{disabled mode} to trigger reallocation of all \gls{MongoDB} processes to another slave.
	\end{itemize}
	\item \glslink{maintenance mode}{maintenance}\\
	\mamid ignores unexpected slave behavior if the slave is in maintenance mode.\\The running MongoDB processes on the slave are not modified / reconfigured and no reallocation to other slaves is triggered.
	\item \glslink{disabled mode}{disabled}\\
	A \gls{slave} in disabled mode does not run any \gls{MongoDB} process controlled by the slave process. When a \gls{slave} with MongoDB processes in a \gls{replica set} is set to disabled mode, \mamid stops all these processes and configures new ones on other \glspl{slave} to repair the temporarily degraded replica set.
\end{itemize}

\textbf{Note}: all state changes apart from \textit{active} $\leftrightarrow$ \textit{unknown} are triggered by the \gls{administrator}.

If \ref{OC:auto_repair} is implemented the state change \textit{unknown} $\rightarrow$ \textit{disabled} can be triggered automatically.

\subsection{Graphical User Interface (GUI)}\label{SM:GUI}
\begin{description}
	%React-JS und so...
	\oitem{SM}{gui_model} GUI::Model\\
	Data structures representing \mamid entities that are displayed or managed through the web interface (\ref{SM:gui_view}). (\ref{F:gui_crud_inventory}, \ref{F:gui_set_slave_type}, \ref{F:gui_set_root_data_dir}, \ref{F:gui_set_risk_groups}, \ref{F:gui_set_slave_mode}, \ref{F:gui_crud_replica_sets})
	\oitem{SM}{gui_view} GUI::View\\
	Web interface and its UI elements. (\ref{F:gui_crud_inventory}, \ref{F:gui_crud_replica_sets}, \ref{F:gui_display_errors}, \ref{OF:gui_display_machine_metrics}, \ref{OF:gui_display_repl_status}, \ref{OF:gui_auto_discovery_interface})
	\oitem{SM}{} GUI::Controller\\
	Handles UI interaction, updates model and asserts semantic consistency between \ref{SM:gui_view} and \ref{SM:gui_model}.
\end{description}
\subsection{NotificationManager}\label{SM:NotificationManager}
\begin{description}
	\oitem{SM}{notif_mail} NotificationManager::MailNotifier\\
	Sends e-mail messages. (\ref{F:notifmgr_send_emails})
	\oitem{SM}{notif_apiclient} NotificationManager::APIClient\\
	\acrshort{API} client for \ref{SM:masterapiserver}. (\ref{F:notifmgr_consume_errors})
	\oitem{SM}{notif_controller} NotificationManager::Controller\\
	Uses \ref{SM:notif_apiclient} and \ref{SM:notif_mail} to implement notification of the \glspl{administrator}. (\ref{F:notifmgr_controller_send_errors}, \ref{F:notifmgr_read_conf_file})
\end{description}

\section{Product Data}\label{ProductData}

\subsection{Data}

\subsubsection{Slaves}\label{D:Inventory}
% hostname(PRIMARY KEY) | slaveport | mongod-portrange | persistent/volatile | root data directory | mode (active, maint, disabled)

List of tuples containing the following data

\begin{description}
	\oitem{D}{} hostname\\
			 The hostname of the \gls{slave}. Must be resolvable from all cluster hosts.
	\oitem{D}{} slave port $\in \mathbb{N}$\\
			The port where the \gls{slave} process listens for connections from the \gls{master}.
	\oitem{D}{slave_mongod_portrange} mongod-port range $\in \{{[i, j]} \mid i,j \in \mathbb{N} \land i < j\}$\\
			 Port range reserved for MongoDB processes spawned by the slave process.\\
			 Depending on the host operating system, this may be restricted to ports $i \geq 1024$.\\
			 Also, implicitly specifies how many \gls{MongoDB} instances may run on the host.
	\oitem{D}{} \gls{root data directory}\\
			 Base directory holding all files of a \gls{slave} and its \gls{MongoDB} instances.
	\oitem{D}{inv_persistence} persistence $\in \{\text{\glslink{persistent storage}{persistent}}, \text{\glslink{volatile storage}{volatile}}\}$\\
			 Specifies whether the \gls{root data directory} is backed by \glslink{persistent storage}{persistent} or \glslink{volatile storage}{volatile} storage.
	\oitem{D}{} mode $\in \{\text{\glslink{active mode}{active}}, \text{\glslink{maintenance mode}{maintenance}}, \text{\glslink{disabled mode}{disabled}}, \text{\hyperref[SM:SlaveModes]{unknown}}\}$\\
			  Described in detail in \ref{SM:SlaveModes}.
\end{description}

\subsubsection{Replica Set Configuration}
%----------------------------- ADMIN SETTABLE ------------------------------------------------------------  ---Allocator settable--  
% replset | p = num of persistent slaves | v = num of volatile slaves | sharding config server (true|false) | p+v mongod processes 
List of tuples containing the following data

\begin{description}
	\oitem{D}{} \gls{replica set} name\\
			  Name of the replica set. Unique among all replica sets deployed in the cluster.
	\oitem{D}{} number of \glslink{persistent storage}{persistent} slaves $p$\\
			  Required number of members (MongoDB processes) with persistently stored data (\ref{D:inv_persistence}).
	\oitem{D}{} number of \glslink{volatile storage}{volatile} slaves $v$\\
  			  Required number of members (MongoDB processes) with volatilely stored data (\ref{D:inv_persistence}).
	\oitem{D}{} \gls{sharding} configuration server $\in \{\text{true}, \text{false}\}$\\
			  If $\textit{true}$, specifies that the configuration of the replica set must be compatible with the requirements host a \gls{MongoDB} \glslink{sharding}{sharding config server}.
	\oitem{D}{} member mongod processes (list of length $p+v$)\\
			  Only managed by \hyperref[SM:Master]{Master}, used to track the members of the replica set.
\end{description}

\subsubsection{MongoDB processes}
%(hostname | port != slaveport) PRIMARY KEY
List of tuples describing all MongoDB processes the \hyperref[SM:Master]{Master} is managing in the cluster.

\begin{description}
	\oitem{D}{} hostname\\
			  The hostname of the machine the process is running on.
	\oitem{D}{} port\\
			  The port where the process listens for connections.
	\oitem{D}{} parent replica set\\
			  The replica set the process belongs to.
\end{description}

\subsubsection{Risk Groups}
\begin{description}
	\oitem{D}{} Mutually disjoint sets of \glspl{slave}. Membership of two \glspl{slave} in the same set denotes a shared risk of failure.
\end{description}

\subsubsection{Notification Contacts}
Contact list for problem notifications.
\begin{description}
	\oitem{D}{} List of e-mail addresses.
\end{description}

\subsection{Data Consistencies}
\begin{description}
	% Foreign keys
	\oitem{DC}{} There is a $1:n$ relationship between replica sets and MongoDB processes ($n \in \mathbb{N}$).
	\oitem{DC}{} There is a $m:n$ relationship between slaves and MongoDB processes ($m,n \in \mathbb{N}$).
	
	%Relationship Mongod <-> host
	\oitem{DC}{} A MongoDB process's \textit{hostname} is the hostname of the \textit{slave} it is running on.
	\oitem{DC}{} A MongoDB process's $\textit{port} \in \text{mongod-port range}$ of the \textit{slave} it is running on.
	\oitem{DC}{} A tuple of MongoDB (\textit{hostname, port}) must be unique in the list of MongoDB processes.
	\oitem{DC}{} A \textit{slave} port must not be $\in \text{its mongod-portrange}$. 
	
	% Risk groups
	\oitem{DC}{} Risk Groups must only contain \glspl{slave} (e.g. identified by their \textit{hostname}) that are defined in the \gls{inventory}.
	
	%Arbiters
	\oitem{DC}{} The number of nodes $p+v$ in a replica set must be odd unless \hyperref[WK:deploy_arbiters]{automatic arbiters} are implemented.
\end{description}


\section{Functional Requirements}
% Format: Substantiviertes Verb am Anfang („Bestimmen von X“, nicht „Bestimmung von X“, „Bestimme X“ oder „X bestimmen”).
\textbf{Note:} Functional requirements derived from mandatory criteria (\ref{MandatoryCriteria}) are indexed by \textbf{F}. 
Functional requirements derived from optional criteria (\ref{OptionalCriteria}) are indexed by \textbf{OF}.
\subsection{Graphical User Interface (GUI)}
The \acrshort{gui} acts as a frontend to the functionality provided by \hyperref[SM:masterapiserver]{Master::APIServer}. Hence, most functionality described in this subsection is realized through \acrshort{API} calls to the \gls{master}.
\begin{description}
	\oitem{F}{gui_crud_inventory} \acrshort{CRUD} \glspl{slave} in \gls{inventory}.
	\begin{description}
		\oitem{F}{gui_crud_inventory_confirm_removal} Prompt for confirmation when removing a slave from the inventory.
	\end{description}
	\oitem{F}{gui_set_slave_type} Specify type of \gls{slave} (\ref{MC:available_slave_types}) upon insertion into \gls{inventory}.
	\oitem{F}{gui_set_root_data_dir} Specify \gls{root data directory} of \glspl{slave} (\ref{MC:root_data_directory}).
	\oitem{F}{gui_set_risk_groups} \acrshort{CRUD} \glspl{risk group} (\ref{MC:spec_risk_groups}).
	\begin{description}
		\oitem{F}{gui_crud_risk_groups_confirm_removal} Prompt for confirmation when removing a risk group.
	\end{description}
	\oitem{F}{gui_set_slave_mode} Set mode of \gls{slave} to \glslink{active mode}{active}, \glslink{maintenance mode}{maintenance} or \glslink{disabled mode}{disabled}.
	\oitem{F}{gui_crud_replica_sets} \acrshort{CRUD} \gls{replica set} configurations (\ref{MC:replica_set_create}).
	\begin{description}
		\oitem{F}{gui_crud_replica_sets_confirm_removal} Prompt for confirmation when removing a replica set.
	\end{description}
	\oitem{F}{gui_display_errors} Display error reports (\ref{F:master_api_error_reports}).
	\oitem{OF}{gui_display_machine_metrics} Display machine metrics of the \glspl{slave}. 
	\oitem{OF}{gui_display_repl_status} Display replication status of the configured \glspl{replica set}.
	\oitem{OF}{gui_auto_discovery_interface} Provide interface to select auto-discovered \glspl{slave} when adding to \gls{inventory} (\ref{F:gui_crud_inventory}).
	\oitem{OF}{gui_command_line_parameters_interface} Provide interface to specify --- per replica set --- command line parameters for the member \gls{MongoDB} processes (\ref{OC:tweak_performance_parameters}).
\end{description}

\subsection{Master}
\subsubsection{API Server}
\begin{description}
	\oitem{F}{master_api_crud_slaves} Provide \acrshort{API} to \acrshort{CRUD} \glspl{slave} in \gls{inventory} (\ref{MC:inventory_definition}).
	\oitem{F}{master_api_crud_risk_groups} Provide \acrshort{API} to \acrshort{CRUD} \glspl{risk group}.
	\oitem{F}{master_api_set_slave_mode} Provide \acrshort{API} to set mode of \gls{host} to \glslink{active mode}{active}, \glslink{maintenance mode}{maintenance} or \glslink{disabled mode}{disabled}.
	\oitem{F}{master_api_crud_repl_set_config} Provide \acrshort{API} to \acrshort{CRUD} \gls{replica set} configurations (\ref{MC:replica_set_create}, \ref{MC:replica_set_config_profiles}, \ref{MC:replica_set_member_pv_counts}).
	\oitem{F}{master_api_error_reports} Provide \acrshort{API} to retrieve error reports (\ref{MC:detect_slave_unexpected_behavior}).
	\oitem{OF}{master_api_get_auto_discovered_slaves} Provide \acrshort{API} to retrieve a list of auto-discovered \glspl{slave} (\ref{OC:manual_autodiscovery}).
	\oitem{OF}{master_api_machine_metrics} Provide \acrshort{API} exposing machine metrics of the \glspl{slave}.
	\oitem{OF}{master_api_repl_set_status} Provide \acrshort{API} exposing \gls{replica set} replication status of the configured \glspl{replica set}.
	\oitem{OF}{} Require authentication from clients (\ref{OC:api_authentication}).
	\oitem{OF}{master_api_command_line_parameters} Provide API to specify --- per replica set --- command line parameters for the member \gls{MongoDB} processes (\ref{OC:tweak_performance_parameters}).
\end{description}
\subsubsection{Monitor}
\begin{description}
	\oitem{F}{master_monitor_config} Monitor configuration \& state of \gls{MongoDB} instances running on \gls{cluster} hosts (\ref{MC:detect_slave_unexpected_behavior}).
	\oitem{OF}{master_monitor_icmp} Monitor reachability of \gls{cluster} hosts via \acrshort{ICMP} (\ref{OC:monitor_icmp}).
	\oitem{OF}{} Monitor machine metrics of the \glspl{slave} (load, disk usage, etc) and alert the \gls{administrator} when thresholds are exceeded (\ref{OC:extended_monitoring}).
	\oitem{OF}{} Monitor \gls{MongoDB} log output and alert the administrator when errors are reported through the log (\ref{OC:extended_monitoring}).
	\oitem{OF}{master_monitor_continuous_auto_discovery} Continuously auto-discover \glspl{slave} on the \gls{cluster} network and add them to the \gls{inventory} (\ref{OC:continuous_autodiscovery}). % move
\end{description}
\subsubsection{Inventory}
\begin{description}
	\oitem{F}{master_inventory_persist_conf_state} Persist and provide the \gls{cluster} configuration \& state (\gls{inventory}).
	\oitem{OF}{master_inventory_export_import_snapshot} Export \& import a consistent snapshot of the \gls{inventory} for backup purposes (\ref{OC:export_import_snapshot}).
\end{description}
\subsubsection{Controller}
\begin{description}
	\oitem{OF}{master_controller_auto_repair} Use spare \glslink{active mode}{active} slaves to automatically repair replica sets: redeploy members on \glslink{disabled mode}{disabled} slaves to the spare slaves (\ref{OC:auto_repair}).\\
	 (Automates administrative decision to flag a host as \glslink{disabled mode}{disabled}. \ref{SM:SlaveModes})
\end{description}
\subsubsection{Cluster Allocator}
\begin{description}
	\oitem{F}{layout_cluster_config} Lay out the \gls{cluster} configuration, i.e. decide on a \gls{replica set} configuration
	\begin{description}
		\oitem{F}{master_alloc_resp_risk_groups} respecting specified \glspl{risk group} by not configuring a replica set with \gls{MongoDB} processes on \glspl{host} sharing the same risk group. \\Only mutually disjoint sets of risk groups are allowed (\ref{MC:spec_risk_groups}).
		\oitem{F}{master_alloc_resp_mode} respecting the mode of \glspl{slave}, following the behavior described in \ref{SM:SlaveModes}.
		\oitem{F}{master_alloc_resp_pv_counts} respecting the administrator-configured number of $p$ persistent \& $v$ volatile \gls{replica set} members per \gls{replica set}, given that
			\begin{flalign*} %align left
			p \in \mathbb{N}_0 \text{ persistent members}  \\
			v \in \mathbb{N}_0 \text{ volatile members} \\
			(p+v) >= 3 \land (p+v) \text{ odd}
			\end{flalign*}
			(\ref{MC:replica_set_member_pv_counts} and \ref{MC:available_slave_types})
		\oitem{OF}{master_alloc_arbiters} adding \gls{MongoDB} \glspl{arbiter} where necessary (\ref{OC:deploy_arbiters}).
	\end{description}
	\oitem{F}{master_alloc_communicate_config} Communicate the \gls{MongoDB} instance configuration to the \glspl{slave} (\ref{MC:mongod_deployment1}).
\end{description}
\subsubsection{Miscellaneous}
\begin{description}
\oitem{OF}{} Provide ability to deploy --- per replica set --- administrator-defined \gls{MongoDB} configuration file templates (\ref{OC:tweak_performance_parameters}).
\end{description}

\subsection{MasterSlaveProtocol}
\begin{description}
	\oitem{F}{msp_trans_config} Transport \gls{replica set} configuration description of \gls{cluster} hosts.
	\oitem{F}{msp_trans_reachability} Transport reachability check messages.
	\oitem{OF}{msp_trans_mach_metr} Transport machine metrics of \glspl{slave}.
	\oitem{OF}{msp_trans_repl_status} Transport \gls{replica set} replication status of \gls{MongoDB} processes on \glspl{slave}.
	% Wunschkriterien erweiteretes Monitoring
\end{description}

\subsection{Slave}
\begin{description}
	% Controller
	\oitem{F}{slave_enforce_config} Apply \gls{MongoDB} process configuration description received from \gls{master} through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol} (\ref{MC:mongod_deployment1}).
	% Process manager
	\oitem{F}{slave_control_procs} Spawn / Control / Kill \gls{MongoDB} processes (\ref{MC:mongod_deployment2}).
	% MongoDB Client
	\oitem{F}{slave_communicate_with_mongodb} Communicate with \gls{MongoDB} processes using \hyperref[SM:mongodbclient]{MongoDBClient}.
	% Controller again
	\oitem{F}{slave_report_config} Report current configuration through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol}.
	\oitem{OF}{slave_report_machine_metrics} Report machine metrics through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol}.
	\oitem{OF}{slave_report_repl_status} Report \gls{replica set} replication status through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol}.
\end{description}

\subsection{NotificationManager}
\begin{description}
	% API Client
	\oitem{F}{notifmgr_consume_errors} Consume error reporting \acrshort{API} of \gls{master} \ref{F:master_api_error_reports}.
	% Controller
	\oitem{F}{notifmgr_controller_send_errors} Send error reports from \ref{F:master_api_error_reports} to configured list of contacts.
	\oitem{F}{notifmgr_read_conf_file} Read list of contacts from a text-based configuration file.
	% Mail Notifier
	\oitem{F}{notifmgr_send_emails} Send error reports via e-mail messages to a contact's address.
\end{description}

\subsection{Command Line Interface (CLI)}
The \acrshort{cli} is an \emph{optional} functional requirement. It acts as a frontend to the functionality provided by \ref{SM:masterapiserver}. Hence, all functionality described in this subsection is realized through \acrshort{API} calls to the \gls{master}.
\begin{description}
	\oitem{OF}{cli_crud_inventory} \acrshort{CRUD} \glspl{slave} in (\gls{inventory}).
	\oitem{OF}{cli_set_slave_type} Specify type of slave (\ref{MC:available_slave_types}) on insertion into \gls{inventory}.
	\oitem{OF}{cli_set_root_data_dir} Specify \gls{root data directory} of \glspl{slave} (\ref{MC:root_data_directory}).
	\oitem{OF}{cli_set_risk_groups} \acrshort{CRUD} \glspl{risk group} (\ref{MC:spec_risk_groups})
	\oitem{OF}{gui_set_slave_mode} Set mode of \gls{host} to \glslink{active mode}{active}, \glslink{maintenance mode}{maintenance} or \glslink{disabled mode}{disabled}.
	\oitem{OF}{cli_crud_replica_sets} \acrshort{CRUD} \gls{replica set} configurations (\ref{MC:replica_set_create}).
	\oitem{OF}{cli_display_errors} Display error reports (\ref{F:master_api_error_reports}).
	\oitem{OF}{cli_display_machine_metrics} Display machine metrics of the \glspl{slave}. 
	\oitem{OF}{cli_display_repl_status} Display replication status of the configured \glspl{replica set}.
\end{description}

\section{Non-Functional Requirements and Constraints}

\subsection{Non-Functional Requirements}
\begin{description}
	% Usability
	\oitem{NF}{} The \gls{administrator} does not need extended knowledge of \gls{MongoDB} to configure \glspl{replica set} using \mamid. %todo cannot measure
	\oitem{NF}{} The \acrshort{gui} needs to be intuitive to \glspl{administrator} familiar with similar tools. %TODO cannot measure
	% Reliability
	\oitem{NF}{} \mamid can handle an unordered parallel reboot of an arbitrary number of hosts in the cluster.
	\oitem{NF}{} The \gls{cluster} is resilient against unexpected failures of \glspl{slave}. %todo cannot measure
	% Performance
	\oitem{NF}{} The \acrshort{gui} responds to user interaction within $500ms$.
	\oitem{NF}{} \mamid supports at least 100 \glspl{slave} in the \gls{cluster}.
	% Maintainability
	\oitem{NF}{} \mamid should be easily portable to all of the POSIX-compliant platforms supported by the version of MongoDB specified in \ref{subsec:Software}.
\end{description}

\subsection{Constraints}
\begin{description}
	\oitem{NF}{} The \hyperref[SM:masterapiserver]{Master API} protocol is \acrshort{JSON} over \acrshort{HTTP}.
	\oitem{NF}{} The \hyperref[SM:masterapiserver]{Master API} is stateless.
	\oitem{NF}{} Implementation Languages
	\begin{itemize}
		\item Golang (\hyperref[SM:Master]{Master}, \hyperref[SM:Slave]{Slave}, \hyperref[SM:MasterSlaveProtocol]{MasterSlaveProtocol}, \hyperref[SM:NotificationManager]{NotificationManager})
		\item HTML, CSS, JavaScript (\hyperref[SM:GUI]{GUI})
	\end{itemize}
	\oitem{NF}{} Team Communication: Slack, GitHub, E-mail
	\oitem{NF}{} Documentation: \LaTeX{}
	\oitem{NF}{} UML-Designer UMLet
	\oitem{NF}{} Version Control: Git
	%TODO \item[Quality Assurance] ... %TODO
\end{description}
% \uiel{name}{type}{text} within itemize
\section{Graphical User Interface (GUI)} %TODO refs to funct. req.

\subsection{Overview}\label{subsec:ui:overview} % TODO redo the dashboard description
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/dashboard}
	\caption{Overview View}
\end{figure}
The \textit{Overview View} summarizes the current state of the cluster.
\begin{itemize}
	\uiel{Current Problems}{section}{lists up to $n \in \mathbb{N}$ slaves \& replica sets with problems.}
	\uiel{Slave States}{section}{chart visualizing the distribution of slave states among all configured slaves.}
\end{itemize}

\subsection{Problems View}\label{subsec:ui:problems_view}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/problems}
	\caption{Problems View}
\end{figure}
The \textit{Problems View} displays unexpected behavior and other errors detected by the \hyperref[SM:Monitor]{Monitor} (\ref{F:gui_display_errors}).

\subsection{Slaves View}\label{subsec:ui:slaves_view}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/slaves}
	\caption{The Slaves View}
\end{figure}
The \textit{Slaves View} provides an overview of the inventory (\ref{F:gui_crud_inventory}).\\
\begin{itemize}
	\uiel{Active}{section}{shows all \glslink{active mode}{active} slaves}.
	\uiel{Unknown}{section}{shows all slaves in \hyperref[SM:SlaveModes]{unknown} state}.
	\uiel{Maintenance}{section}{shows all slaves in \gls{maintenance mode} (not in figure)}.
	\uiel{Disabled}{section}{shows all \glslink{disabled mode}{disabled} slaves}.
\end{itemize}
Clicking the wrench icon opens the slave modification UI (\ref{subsec:ui:modify_slave}).

\subsubsection{Adding a Slave}\label{subsec:ui:add_slave}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/new_slave}
	\caption{New Slave Wizard}
\end{figure}
In the \textit{Add Slave Wizard} the user can add a new \gls{slave} with the specified options to the \gls{inventory}.
\subsubsection{Modifying a Slave}\label{subsec:ui:modify_slave}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/slave_edit_active.png}
	\caption{The Slave View with a slave in 'active' state}
\end{figure}
In the \textit{Slave View} the user can modify the options of a slave and set it into the desired state. Depending on the state different options are available (see following figures).

In \gls{active mode} the user can set the slave into
\begin{itemize}
	\item \gls{maintenance mode}
	\item \gls{disabled mode}
\end{itemize}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/slave_edit_unknown.png}
	\caption{The Slave View with a slave in 'unknown' state}
\end{figure}
In unknown mode the user can set the slave into
\begin{itemize}
	\item \gls{maintenance mode}
	\item \gls{disabled mode}
\end{itemize}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/slave_edit_maintenance}
	\caption{The Slave View with a slave in 'maintenance mode'}
\end{figure}
In \gls{maintenance mode} the user can set the slave into
\begin{itemize}
	\item \gls{active mode}
	\item \gls{disabled mode}
\end{itemize}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/slave_edit_disabled.png}
	\caption{The Slave View with a slave in 'disabled' state}
\end{figure}
In \gls{disabled mode} the user can set the slave into
\begin{itemize}
	\item \gls{active mode}
	\item \gls{maintenance mode}
\end{itemize}
and also remove the slave (see \ref{subsec:ui:remove_slave}).
\subsubsection{Removing a Slave}\label{subsec:ui:remove_slave}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/slave_remove}
	\caption{Removing a slave}
\end{figure}
In the \textit{Slave View}, the user can remove the slave from the inventory by clicking the red \textit{Remove Slave} button (\ref{F:gui_crud_inventory}, \ref{F:gui_crud_inventory_confirm_removal}).

However, confirmation through a modal dialog is required (see above).

\subsection{Risk Groups View}\label{subsec:ui:risk_groups_crud}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/risk_groups}
	\caption{The Risk Groups View}
\end{figure}
The \textit{Risk Groups View} enables CRUD of \glspl{risk group} (\ref{F:gui_set_risk_groups}).
\begin{itemize}
	\uiel{Assignable Slaves}{section}{Slaves that are not member of a risk group.}
	\item Subsequent sections: each represents a risk group. Can be clicked to expand \& view the the risk group members.
	\begin{itemize}
		\uiel{Trash Bin}{button}{Click to delete the risk group after confirmation (see figure below). All members of the deleted risk group are then re-added to the \textit{Assignable Slaves section}.}
	\end{itemize}
	\uiel{Create}{button}{Click to create a new risk group with the name entered into the text field on the left of the \textit{Create button}.}
\end{itemize}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/risk_groups_remove_confirmation}
	\caption{The Risk Groups View prompting for confirmation on removal of a risk group}
	\label{subsec:ui:risk_groups_removal_confirmation}
\end{figure}

\subsection{Replica Sets View}\label{subsec:ui:replica_sets_view}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/replica_sets}
	\caption{The Replica Sets view}
\end{figure}
The \textit{Replica Sets View} enables inspection and management of replica sets (\ref{F:gui_crud_replica_sets}).
\begin{itemize}
	\uiel{Degraded}{section}{lists all configured replica sets with problems, e.g. a member process running on a \gls{slave} in \gls{maintenance mode}}.
	\uiel{Active}{section}{lists all configured replica sets without known problems}.
\end{itemize}
Clicking the wrench icon opens the replica set modification UI (\ref{subsec:ui:modify_replica_set}).

\subsubsection{Adding a Replica Set}\label{subsec:ui:new_replica_set}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/new_replica_set}
	\caption{New Replica Set Wizard}
\end{figure}
The \textit{New Replica Set Wizard} is opened by clicking the corresponding button in the sidebar.
\pagebreak % release looks ugly otherwise
\subsubsection{Modifying a Replica Set}\label{subsec:ui:modify_replica_set}
The \textit{Replica Set View} provides information on each member slave's state.
\begin{itemize}
	\uiel{Sharding configuration server}{checkbox}{is read-only.}
	\uiel{Persistent / Volatile nodes}{numericfield}{can be changed.}
	\uiel{Apply}{button}{submits the changed replica set configuration to the \hyperref[SM:Master]{Master}.}
	\uiel{Remove}{button}{removes the replica set (prompting for confirmation first, see figure \ref{fig:replica_set_remove}).}
\end{itemize}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/replica_set_overview_active.png}
	\caption{Replica Set View with a normal operating replica set}
\end{figure}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/replica_set_overview_degraded}
	\caption{Replica Set View with a degraded replica set}
\end{figure}
\subsubsection{Removing a Replica Set}\label{subsec:ui:remove_replica_set}
\begin{figure}[H]
	\centering
	\mamidscreenshot{screenshots/replica_set_remove}
	\caption{Removing a replica set}
	\label{fig:replica_set_remove}
\end{figure}
After clicking the red \textit{Remove Replica Set} button in the \textit{Replica Set View}, the user is prompted for confirmation.
\begin{itemize}
	\uiel{Remove Replica Set}{button} deletes the replica set.
	\uiel{Cancel}{button} cancels the deletion operation and dismisses the prompt.
\end{itemize}

%Form:
%Name [: Beschreibung]
%Beschreibung: satz ohne subjekt, also klein und ohne Punkt; Strichpunkt getrennt

%\begin{enumerate}
%\item
%\end{enumerate}

%text...

\section{Test Scenarios}
Unless explicitly stated, the \acrshort{gui}'s \textit{Overview} page is always opened at the beginning of a test scenario (\ref{subsec:ui:overview}).

\begin{description}

\oitem{TS}{} Adding Machines to the Cluster
\testsequence
[\ref{F:gui_crud_inventory}, \ref{F:master_api_crud_slaves}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}]
{
	A machine $M$ with installed \gls{slave} software is connected to the \gls{cluster} network. The \gls{administrator} configures that the \gls{slave} software is started on boot.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the \textit{Slaves View} in the \hyperref[SM:GUI]{GUI}.
		\item The \gls{administrator} adds the slave $S$ on $M$ using the \textit{Add Slave View}.
		\item The \gls{administrator} navigates to the \textit{Risk Groups View}.
		\item The \gls{administrator} assigns the slave to the correct risk group.
		\item The \gls{administrator} navigates to the \textit{Slaves View} in the \hyperref[SM:GUI]{GUI}.
		\item The \gls{administrator} selects $S$ and sets it from \gls{disabled mode} to \gls{active mode}.
	\end{itemize}
}

\oitem{TS}{} Removing Machines from the Cluster
\testsequence
[\ref{F:gui_crud_inventory}, \ref{F:gui_crud_inventory_confirm_removal}, \ref{F:master_api_crud_slaves}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_communicate_config}]
{
	A machine $M$ with installed \gls{slave} software shall be removed from the cluster.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the \textit{Slaves View} in the \hyperref[SM:GUI]{GUI}.
		\item The \gls{administrator} selects the \gls{slave} $S$ running on $M$ and sets it to \gls{disabled mode} (\textit{Slave View}).
		\item The \hyperref[SM:Master]{master} determines a new \gls{cluster} layout to repair $S$'s former \glspl{replica set}.
		\item The \hyperref[SM:Master]{master} communicates the desired configuration to the appropriate \glspl{slave}.
		\item The \textit{Remove} button in the \textit{Slave View} is enabled.
		\item The \gls{administrator} clicks the \textit{Remove} button.
		\item The \hyperref[SM:GUI]{GUI} prompts the \gls{administrator} for confirmation.
		\item The \gls{administrator} confirms the removal by clicking the confirmation prompt's \textit{Remove} button (\ref{subsec:ui:remove_replica_set}).
		\item The \hyperref[SM:Master]{master} removes the slave from the \gls{inventory} and persists the change.
		\item The \hyperref[SM:GUI]{GUI} dismisses the \textit{Slave View} and switches back to the \textit{Slaves View}.
		\item The \gls{administrator} can now physically remove $M$ from the \gls{cluster}.
	\end{itemize}
}


\oitem{TS}{} Temporarily Unreachable Slave
\testsequence
[\ref{F:master_monitor_config}, \ref{F:master_api_error_reports}, \ref{F:gui_display_errors}, \ref{F:gui_set_slave_mode}, \ref{F:msp_trans_reachability}, \ref{F:notifmgr_controller_send_errors}, \ref{F:notifmgr_send_emails}]
{
	A \gls{slave} $S$ becomes unreachable, e.g. because of a broken network cable.
}
{
	\begin{itemize}
		\item The \hyperref[SM:NotificationManager]{NotificationManager} sends an e-mail notification to the \gls{administrator}.
		\item The \gls{administrator} responds to the e-mail notification by opening the \hyperref[subsec:ui:problems_view]{Problems View} in the \hyperref[SM:GUI]{GUI}.
		\item The \hyperref[SM:GUI]{GUI} offers to set $S$ into \glslink{maintenance mode}{maintenance} or \gls{disabled mode}.
		\item The \gls{administrator} does not choose either of the options but replaces the broken cable.
		\item The \hyperref[SM:Master]{Master} reaches $S$ again.
		\item The \hyperref[SM:Master]{Master} determines that configuration is still as expected.
		\item The \hyperref[SM:Master]{Master} removes $S$ from the error report.
	\end{itemize}
}


\oitem{TS}{} Defective Slave
\testsequence
[\ref{F:master_monitor_config}, \ref{F:master_api_error_reports}, \ref{F:gui_display_errors}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:slave_report_config}, \ref{F:msp_trans_config}, \ref{F:msp_trans_reachability}, \ref{F:master_monitor_config}]
{
	A \gls{slave} $S$ becomes permanently unreachable, e.g. because there was a short-circuit on its mainboard which needs to be replaced. The admin has no spare mainboards left and has to wait for replacement hardware to arrive. However, there is at least one \glslink{active mode}{active} \gls{slave} allowed to take over the role of the failed one.
}
{
	\begin{itemize}
		\item After $S$ becomes unavailable the \hyperref[SM:NotificationManager]{NotificationManager} sends an e-mail notification to the \gls{administrator}.
		\item The \gls{administrator} responds to e-mail notification by opening the  \hyperref[subsec:ui:problems_view]{Problems View} in the \hyperref[SM:GUI]{GUI}.
		\item The \hyperref[SM:GUI]{GUI} offers to set $S$ into \glslink{maintenance mode}{maintenance} or \gls{disabled mode}.
		\item The \gls{administrator} chooses \gls{disabled mode}.
		\item The \hyperref[SM:Master]{Master} selects a \gls{slave} $S'$ as a replacement for $S$ and communicates the appropriate configuration to $S'$
		\item $S'$ starts a new \gls{MongoDB} process and enforces the received configuration.
		\item $S'$ reports successful configuration to \hyperref[SM:Master]{master}.
		\item The \hyperref[SM:Master]{Master} removes $S$ from the error report.
	\end{itemize}
}


\oitem{TS}{} System Maintenance
\testsequence
[\ref{F:gui_crud_inventory}, \ref{F:master_api_crud_slaves}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:slave_report_config}, \ref{F:msp_trans_config}]
{
	A \gls{slave} $S$ needs to be rebooted to install security updates to the installed software.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the \textit{Slaves View} in the \hyperref[SM:GUI]{GUI}.
		\item The \gls{administrator} selects $S$ and sets it to \gls{maintenance mode}.
		\item The \gls{administrator} installs the security updates and reboots the machine (killing the \gls{slave} instance and all its \gls{MongoDB} instances).
		\item The \gls{slave} process $S$ is restarted by the system's service manager after reboot.
		\item The \gls{administrator} sets $S$ back to \gls{active mode}.
		\item The \hyperref[SM:Master]{master} communicates the desired configuration to $S$.
		\item $S$ starts the \gls{MongoDB} processes and configures \gls{replica set} membership if required by the communicated configuration.
	\end{itemize}
}


\oitem{TS}{} Adding a Replica Set
\testsequence
[\ref{F:gui_crud_replica_sets}, \ref{F:master_api_crud_repl_set_config}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:msp_trans_config}]
{
	The \gls{administrator} wants to add a \gls{replica set} $R$ with $p \in \mathbb{N}$ \glslink{persistent storage}{persistent} members and $v \in \mathbb{N}$ \glslink{volatile storage}{volatile} members. $(p+v) >= 3 \land (p+v) \textit{ is odd}$. Enough \glspl{slave} with sufficient free \gls{MongoDB} \hyperref[D:slave_mongod_portrange]{ports} are available.
}
{
	\begin{itemize}
		\item The \gls{administrator} opens the \textit{New Replica Set Wizard} \ref{subsec:ui:new_replica_set}.
		\item The \gls{administrator} fills in the fields with the appropriate values (see \textit{Preconditions}).
		\item The \hyperref[SM:Master]{master} finds appropriate \glspl{slave} for hosting members of $R$ (\hyperref[SM:master_clusterallocator]{Master::ClusterAllocator}).
		\item The \hyperref[SM:Master]{master} communicates the desired configuration to the appropriate \glspl{slave}.
		\item These \glspl{slave} apply the received configuration to the respective MongoDB processes.
	\end{itemize}
}


\oitem{TS}{} Modifying a Replica Set
\testsequence
[\ref{F:gui_crud_replica_sets}, \ref{F:master_api_crud_repl_set_config}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:msp_trans_config}]
{
	The \gls{administrator} wants to increase the number of volatile nodes in a replica set $R$ by $k \in \mathbb{N}$. Enough \glspl{slave} with sufficient free \gls{MongoDB} \hyperref[D:slave_mongod_portrange]{ports} are available.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the \textit{Replica Sets View} (\ref{subsec:ui:replica_sets_view}).
		\item The \gls{administrator} selects the replica set $R$.
		\item The web interface presents the \textit{Replica Set View} (\ref{subsec:ui:modify_replica_set}).
		%Sharding config server setting is not modifiable.
		\item The \gls{administrator} increases the number of volatile nodes by $k$ and applies the changes.
		\item The \hyperref[SM:Master]{master} finds appropriate \glspl{slave} for hosting the new members of the replica set (\hyperref[SM:master_clusterallocator]{Master::ClusterAllocator}).
		\item The \hyperref[SM:Master]{master} communicates the desired configuration to the appropriate \glspl{slave}
		\item The \glspl{slave} apply the received configuration.
	\end{itemize}
}


\oitem{TS}{} Destroying a Replica Set
\testsequence
[\ref{F:gui_crud_replica_sets}, \ref{F:master_api_crud_repl_set_config}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:msp_trans_config}, \ref{F:gui_crud_replica_sets_confirm_removal}]
{
	The \gls{administrator} wants to destroy a \gls{replica set} $R$.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the \textit{Replica Sets View} (\ref{subsec:ui:replica_sets_view}).
		\item The \gls{administrator} selects the replica set $R$.
		\item The web interface presents the \textit{Replica Set View} (\ref{subsec:ui:modify_replica_set}).
		\item The \gls{administrator} clicks the \textit{remove button}.
		\item The \hyperref[SM:GUI]{GUI} prompts the \gls{administrator} for confirmation (\ref{F:gui_crud_replica_sets_confirm_removal}).
		\item The \gls{administrator} confirms the removal by clicking the confirmation prompt's \textit{remove button} (\ref{subsec:ui:remove_replica_set}).
		\item The \hyperref[SM:Master]{master} persists the change and communicates to the \glspl{slave} hosting members of $R$ to kill the respective \gls{MongoDB} processes.
		\item The \glspl{slave} apply the received instructions.
	\end{itemize}
}

\oitem{TS}{} Modifying a Slave
\testsequence
[\ref{F:gui_crud_inventory}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_crud_slaves}, \ref{F:master_api_set_slave_mode}, \ref{F:master_monitor_config}, \ref{F:master_inventory_persist_conf_state}, \ref{F:master_alloc_communicate_config}]
{
	The hostname of a \gls{host} $H$ hosting \gls{slave} $S$ has to be changed which needs to be announced to \mamid.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to \textit{Slaves View}.
		\item The \gls{administrator} selects the slave $S$ and clicks the edit button.
		\item The web interface presents the \textit{Slave View} (\ref{subsec:ui:modify_slave}).
		\item The \gls{administrator} sets the slave $S$ into maintenance mode.
		\item The \gls{administrator} changes the hostname of the slave $S$ in the web interface and applies the change by clicking the \textit{Apply button}.
		\item The \gls{administrator} changes the hostname on the host $H$ through a mechanism not controlled by \mamid.
		\item The \gls{administrator} sets the slave $S$ back to active mode.
		\item The \hyperref[SM:Master]{Master} reaches the slave under its new host name.
		\item The \hyperref[SM:Master]{Master} updates the configuration of the replica sets with member processes hosted on slave $S$.
	\end{itemize}
}

\oitem{TS}{} Add Risk Group
\testsequence
[\ref{F:gui_set_risk_groups}, \ref{F:master_api_crud_risk_groups}]
{
	The administrator wants to model a shared risk of failure between several \glspl{slave} through risk groups.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the \textit{Risk Groups View} (\ref{subsec:ui:risk_groups_crud}).
		\item The \gls{administrator} creates a new risk group as described in \ref{subsec:ui:risk_groups_crud}.
		\item The empty risk group appears in the \textit{Risk Groups View}.
		\item The drop-down menu used to assign a slave to a risk group in the \textit{Risk Groups View}'s \textit{Assignable Slaves section} contains the new risk group.
	\end{itemize}
}

\oitem{TS}{} Remove Risk Group
\testsequence
[\ref{F:gui_set_risk_groups}, \ref{F:master_api_crud_risk_groups}, \ref{F:gui_crud_risk_groups_confirm_removal}]
{
	The administrator wants to remove the risk group $G$.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the \textit{Risk Groups View} (\ref{subsec:ui:risk_groups_crud}).
		\item The \gls{administrator} finds the section representing $G$ and clicks the corresponding \textit{trash bin button}.
		\item The web interface presents a confirmation dialog (\ref{subsec:ui:risk_groups_removal_confirmation}).
		\item The \gls{administrator} confirms removal of $G$ by clicking the \textit{confirmation button} (\ref{F:gui_crud_risk_groups_confirm_removal}).
		\item The \hyperref[SM:Master]{Master} removes the risk group membership of $G$'s members and persists these changes.
		\item No further reconfiguration of \gls{MongoDB} processes managed by \mamid takes place.
		\item The \textit{Risk Groups View} presents $G$'s former members in the \textit{Assignable Slaves section}.
	\end{itemize}
}

\end{description}


\glsaddallunused
\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space On page ##5.
  }
}
\makeatother
\glsaddall
\printglossary[type=main, title={Glossary}, toctitle={Glossary}, style=myAltlist]

\end{document}
