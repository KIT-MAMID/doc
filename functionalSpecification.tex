% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[fleqn]{amsmath} %left aligned equations
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{amssymb}
\usepackage{calc}
\usepackage{enumitem} 
\usepackage{url}
\usepackage{parskip}

% TODO: template übersetzten

\makeglossaries

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{
  \glsdoifexists{#2}{
    \def\@glsnumberformat{glsgobblenumber}
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}
    \setkeys{glossadd}{#1}
    \@gls@saveentrycounter
    \@do@wrglossary{#2}
  }
}
\renewcommand{\glsaddallunused}[1][]{
  \edef\@glo@type{\@glo@types}
  \setkeys{glossadd}{#1}
  \forallglsentries[\@glo@type]{\@glo@entry}{
    \ifglsused{\@glo@entry}{}{
      \glsaddnp[#1]{\@glo@entry}}}
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

% usage: \counteditem{prefix}{refName} -> item `/prefixXX/` with label `prefix:refName` (where XX is counted in increments of 10)
\makeatletter
\newcommand{\oitem}[2]{
  % define the counter
  \@ifundefined{c@oitem#1}{\newcounter{oitem#1}}{} % initialized at 0
  \addtocounter{oitem#1}{10}
  \item[\namedlabel{#1:#2}{/#1\arabic{oitem#1}/}]
}
\makeatother

% usage: \testfall{szenario}{ablauf}{ergebnis} oder \testfall[\ref{F:getesteteFunktion}]{szenario}{ablauf}{ergebnis}
\newcommand{\testfall}[4][]{
  \begin{description}
    \ifthenelse{\equal{#1}{}}
               {} % optional argument #1 is empty: skip
               {\item[Testet] #1}
    \item[Vorbedingungen] #2
    \item[Ablauf] #3
    \item[Erwartetes Ergebnis] #4
  \end{description}
}

\newcommand{\testsequence}[3][]{
	\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries Preconditions}]
		\ifthenelse{\equal{#1}{}}
		{} % optional argument #1 is empty: skip
		{\item[Tests] #1}
		\item[Preconditions] #2
		\item[Steps] #3
	\end{description}
}

\begin{document}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\mamid}[0]{\textit{KIT-MAMID} }

\include{glossary}

\begin{titlepage}
\makeatletter
\begin{center}
~\\[4em]
{\Huge KIT-MAMID}\\[.8em]\huge{Monitor and Manager for In-Memory Databases}\\[2em]
{\huge Functional specification}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Niklas Fuhrberg\\
Anton Schirg\\
Christian Schwarz\\
Janis Streib\\
Bob Weinand\\[3em]}
supervised by\\[2em]
{\Large
Dr. Marek Szuba\\[1em]}
at\\[1em]
{\Large
Karlsruhe Institute of Technology\\
SCC}

\end{center}
\makeatother
\end{titlepage}
\newpage
\tableofcontents
\newpage

% -------------------------------------------------------------- HIER BEGINNT DAS DOKUMENT WIRKLICH ---------------------------------
\section{Introduction}
\mamid is a manager for database \glspl{cluster}, facilitating creation, administration and monitoring of \gls{MongoDB} \glspl{replica set}.

\mamid assists the \gls{administrator} during initial setup, continuous operation, maintenance cases and expansion of the cluster.

The \gls{administrator} describes the \gls{cluster} \glspl{host} and the desired \gls{MongoDB} \glspl{replica set}.

Each \gls{host} runs a \gls{slave} application of \mamid, allowing control of the \glspl{host} from a single \gls{master} instance of \mamid.

\mamid utilizes the \gls{administrator}'s description of the cluster and replica sets to run \gls{MongoDB} instances on the \glspl{host}.

\mamid configures the \gls{MongoDB} instances to form the desired replica sets.

\mamid monitors the deployed configuration continuously and informs the \gls{administrator} about problems (when they arise).

Maintenance of individual \glspl{host}, growing \& shrinking of the cluster, etc. is announced to \mamid beforehand, allowing for reconfiguration of the deployed \glspl{replica set} if necessary.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{cluster_layout}
	\caption{Possible cluster layout for a single application}
\end{figure}

\section{Objectives \& Criteria}
\subsection{Must-Have Criteria}

\subsubsection{Cluster Description by Administrator}
% TODO analyze whether the given criteria can be phrased more abstractly \& move the details to (new) functional requirements. (-> forward lookup references from criteria to functional requirement if required)
\begin{description}

\oitem{MK}{} The \gls{administrator} interacts with \mamid through a web \acrshort{gui}.

% inventory ops
\oitem{MK}{inventory_definition} The \gls{master} maintains a list of \glspl{slave} called \gls{inventory}.
\oitem{MK}{} The \gls{administrator} can add \glspl{slave} to the \gls{inventory}.
\oitem{MK}{} The \acrshort{gui} visualizes the \gls{inventory}.
\oitem{MK}{} The \gls{administrator} can remove a \gls{slave} that does not host any \gls{MongoDB} processes from the \gls{inventory}.
\oitem{MK}{spec_physical_interdep} The \gls{administrator} can specify \glspl{physical interdependency} between \glspl{slave} in the \gls{inventory}.

% inventory ops -> slave
\oitem{MK}{slave_mode_active} The \gls{administrator} can announce to \mamid that a slave is ready to host MongoDB processes.
\oitem{MK}{slave_mode_maintenance} The \gls{administrator} can announce to \mamid that a slave is under maintenance to inhibit automatic reconfiguration of its MongoDB processes.
\oitem{MK}{slave_mode_disabled} The \gls{administrator} can announce to \mamid that a slave should not host any MongoDB processes.

\oitem{MK}{available_slave_types} The \gls{administrator} can specify whether the \gls{slave} has \glslink{persistent storage}{persistent} or \glslink{volatile storage}{volatile} storage.
\oitem{MK}{root_data_directory} The \gls{administrator} can specify in which filesystem directory on the \gls{host} the \gls{slave} and its \gls{MongoDB} processes store data.

% replica set ops
\oitem{MK}{replica_set_create} The \gls{administrator} can create a new \gls{replica set}.
\oitem{MK}{replica_set_config_profiles} The \gls{administrator} can --- on creation of a replica set (\ref{MK:replica_set_create}) --- specify that it must be usable as a configuration server for \gls{MongoDB} \emph{Sharding} \footnote{\url{https://docs.mongodb.com/manual/core/sharded-cluster-config-servers/\#replica-set-config-servers}}.
\oitem{MK}{replica_set_member_total_counts} The \gls{administrator} can select the number of \gls{MongoDB} instances (members) of a replica set.
\oitem{MK}{replica_set_member_pv_counts} Volatile and persistent member count of a \gls{replica set} can be independently configured, under constraints described in \ref{F:master_alloc_resp_pv_counts}.
\oitem{MK}{} The \acrshort{gui} visualizes the list of configured \glspl{replica set}.
\oitem{MK}{} The \gls{administrator} can destroy a \gls{replica set}.

\end{description}

\subsubsection{MongoDB Configuration \& Monitoring}
\begin{description}
\oitem{MK}{mongod_deployment1} \mamid asserts that the replica sets described by the administrator are configured on the cluster.
\oitem{MK}{mongod_deployment2} To achieve \ref{MK:mongod_deployment1}, \mamid spawns \& controls \gls{MongoDB} processes on the hosts using a \gls{slave} process.
\begin{description}
	\oitem{MK}{mongod_redeployment} \mamid redeploys configured \gls{MongoDB} processes to hosts where the \gls{slave} process reports a situation different from what is expected by the \gls{master}.
	\oitem{MK}{mongod_redeployment_powercycle_specific} Specifically, a host with volatile data storage can loose all data originating from the \gls{slave} process or \gls{MongoDB} and is automatically redeployed with correctly configured \gls{MongoDB} instances (\ref{MK:mongod_deployment2}).
\end{description}
% Todo old \oitem{MK}{} The \gls{master} deploys the \gls{replica set} configuration described by the administrator to the cluster.

% monitoring features
\oitem{MK}{detect_slave_unexpected_behavior} \mamid detects when a \gls{slave} in the \gls{inventory} behaves unexpectedly, e.g. becomes unreachable while no maintenance announced.
\oitem{MK}{} \mamid informs the \gls{administrator} by e-mail about problems in the cluster (\ref{MK:detect_slave_unexpected_behavior}).
\oitem{MK}{} The \acrshort{gui} visualizes \glspl{slave} behaving unexpectedly (\ref{MK:detect_slave_unexpected_behavior}).
\end{description}

\subsection{Optional Criteria}
\begin{description}
	
% master
\oitem{WK}{api_authentication} The \gls{master} requires authentication from \acrshort{API} clients. 
	
% inventory
\oitem{WK}{manual_autodiscovery} The \gls{master} auto-discovers new \glspl{slave} on the \gls{administrator}'s request.
\oitem{WK}{continuous_autodiscovery} The \gls{master} continuously auto-discovers \glspl{slave}.
\oitem{WK}{} The \gls{master} monitors reachability of \gls{cluster} \glspl{host} via ICMP.
\oitem{WK}{} The \gls{master} can export \& import a consistent snapshot of the \gls{inventory} for backup purposes.

% slaves
\oitem{WK}{} The \gls{administrator} can specify arbitrary \gls{MongoDB} command line parameters per \gls{slave}.
\oitem{WK}{} The \gls{administrator} can specify a \gls{MongoDB} configuration file template.

% automatic repair
\oitem{WK}{} The \gls{master} automatically repairs \gls{degraded} \glspl{replica set} with \emph{suitable} \glslink{active mode}{active} \glspl{slave}.

% replica sets
\oitem{WK}{deploy_arbiters} The \gls{master} deploys \gls{MongoDB} \glspl{arbiter} for configured \glspl{replica set}, removing some restrictions in \ref{F:master_alloc_resp_pv_counts}.
\oitem{WK}{} The \gls{master} exposes machine metrics of the \glspl{slave}.
\oitem{WK}{} The \gls{master} exposes the \glspl{replica set}' replication status.

% other
\oitem{WK}{} The \gls{administrator} can interact with \mamid via a \acrshort{cli}.
\oitem{WK}{http_api} The \gls{administrator} can interact with \mamid via a stable, documented \acrshort{HTTP} \acrshort{API}.
\end{description}

\subsection{Demarcation Criteria}
\begin{description}
\oitem{AK}{} The \gls{master} does not implement support for higher-layer \gls{MongoDB} features, e.g. \emph{Sharding}.
\oitem{AK}{} \mamid neither deploys the operating system nor other required software (such as \gls{MongoDB} binaries) to the \gls{cluster} \glspl{host}.
\end{description}

\section{Product Usage}

\subsection{Scope of Application}
\begin{itemize}
\item MongoDB Cluster Administration
\item High-Availibility \gls{MongoDB} Deployment
\item \gls{MongoDB}\glslink{cluster}{Cluster} Monitoring
\end{itemize}

\subsection{Target Users}
\begin{itemize}
\item \glslink{administrator}{Administrators} of \gls{cluster} hosting \mamid deployment
\end{itemize}

\subsection{Operating Conditions}
\begin{itemize}
\item multi-\gls{host} \gls{cluster} on a fast \acrshort{LAN}
\item Low maintenance cost (time, personnel)
\item Uncomplicated takeover of deployment by a successor (flat learning curve)
\end{itemize}

\section{Environment}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{hardware_layout}
	\caption{Possible cluster hardware layout}
\end{figure}

\subsection{Software}\label{subsec:Software}
\begin{itemize}
\item Primary Target Operating System: Open Indiana Build 151a9 (Illumos Kernel, 64bit)
\item MongoDB version 3.2
\end{itemize}

\subsection{Hardware}

Each of the subsequently listed requirements describes the previously defined ones.

\subsubsection{Cluster Hosts Hardware}
\begin{itemize}
	\item 64bit amd64 Instruction Set
	\item Sufficient \glslink{persistent storage}{persistent} or \gls{volatile storage} to hold the required \gls{MongoDB} data. \\
	      Up to $1GB$ file storage for \mamid applications.
	\begin{itemize}
		\item \textbf{Note}: fewer \glspl{host} with \gls{persistent storage} may require the \gls{persistent storage} on these \glspl{host} to be larger.
	\end{itemize}
\end{itemize}

\subsubsection{Deployment of the Cluster}
\begin{itemize}
	\item \glslink{cluster}{Cluster}
	\begin{itemize}
		\item with \gls{cluster} \glspl{host} on an isolated \acrshort{LAN}
		\item with at least one \gls{cluster} \glspl{host} which is
		\begin{itemize}
			\item connected to the \gls{cluster} \gls{host} isolated \acrshort{LAN}
			\item connected to the external network (\acrshort{LAN} or \acrshort{WAN})
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{Operation of Persistently Stored Replica Sets}
\begin{itemize}
	\item $>= 1$ \gls{host} with \gls{persistent storage}
	\item $>= 3$ \glspl{host} in total
\end{itemize}

\subsubsection{Basic Level of Host Redundancy}
\begin{itemize}
	\item $>= 3$ mutually disjoint sets of \gls{cluster} \glspl{host}. \\ \glslink{host}{Hosts} in a set share a common risk of failure, e.g. being on the same power supply. \glslink{host}{Hosts} in different sets do not share this risk.
\end{itemize}

\section{System Model}
\begin{figure}[H]
\includegraphics[width=\textwidth]{module_overview}
\caption{\mamid Modules Overview}
\end{figure}
\subsection{Master}\label{SM:Master}
\begin{description}
	\oitem{SM}{masterapiserver} Master::APIServer\\
	Provides an \acrshort{API} for \gls{cluster} status reporting and administrative activity. (\ref{F:master_api_crud_slaves}, \ref{F:master_api_crud_phys_interdeps}, \ref{F:master_api_set_slave_mode}, \ref{F:master_api_crud_repl_set_config}, \ref{F:master_api_error_reports}, \ref{WF:master_api_get_auto_discovered_slaves}, \ref{WF:master_api_machine_metrics}, \ref{WF:master_api_repl_set_status})
 	\oitem{SM}{} Master::Controller\\
	Controls flow of events between different \gls{master} submodules.\\
	Updates the inventory database (\ref{SM:inventory}) as state change is recognized by the monitor.\\
	Ensures auto-repair of \gls{degraded} \glspl{replica set}. (\ref{WF:master_controller_auto_repair})
	\oitem{SM}{inventory} Master::Inventory\\
	Database containing
	\begin{itemize}
		\item list of \glspl{slave} and associated state
		\item list of configured \glspl{replica set}.
	\end{itemize}
	(\ref{F:master_inventory_persist_conf_state})
	\oitem{SM}{master_clusterallocator} Master::ClusterAllocator\\
	It lays out the \gls{cluster}, i.e. decides the distribution of mongod instances onto \gls{cluster} \glspl{host}. (\ref{F:layout_cluster_config})\\
	It respects constraints as described by \ref{F:master_alloc_resp_phys_interdeps}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode} and \ref{WF:master_alloc_arbiters}.\\
	It communicates with the \glspl{slave} using \ref{SM:masterslaveproto} to enforce the \gls{cluster} layout. (\ref{F:master_alloc_communicate_config})
	\oitem{SM}{master_monitor} Master::Monitor\\
	Is responsible for observing whether \glspl{slave} are still alive using \ref{SM:masterslaveproto} and auto-discovery. (\ref{F:master_monitor_config}, \ref{WF:master_monitor_icmp}, \ref{WF:master_monitor_continuous_auto_discovery})
\end{description}
\subsection{MasterSlaveProtocol}\label{SM:MasterSlaveProtocol}
\begin{description}
	\oitem{SM}{masterslaveproto} MasterSlaveProtocol\\
	Is responsible for communication between \gls{master} and \gls{slave}. (\ref{F:msp_trans_config}, \ref{F:msp_trans_reachability}, \ref{WF:msp_trans_mach_metr}, \ref{WF:msp_trans_repl_status})
\end{description}
\subsection{Slave}\label{SM:Slave}
\begin{description}
	\oitem{SM}{} Slave::Controller\\
	Dispatches instructions to the \glspl{MongoDB} client and the process manager. (\ref{F:slave_enforce_config})\\
	It notifies via \ref{SM:masterslaveproto} whether operations failed or succeeded as well as not locally recoverable failures. (\ref{F:slave_report_config}, \ref{WF:slave_report_machine_metrics}, \ref{WF:slave_report_repl_status})
	\oitem{SM}{mongodbclient} Slave::MongoDBClient\\
	Implements communication with \gls{MongoDB} processes. (\ref{F:slave_communicate_with_mongodb})
	\oitem{SM}{} Slave::ProcessManager\\
	Spawns and controls \gls{MongoDB} processes. (\ref{F:slave_control_procs})
\end{description}
\subsubsection{Slave states}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{state_diagram}
\caption{Slave State Diagram}
\end{figure}
A slave can be in the following states:
\begin{itemize}
	\item \glslink{active mode}{active}\\
	\mamid monitors \glspl{slave} in active mode. If the slave behaves unexpectedly, i.e. is not reachable, \mamid notifies the \gls{administrator} and set its state to unknown.
	\item unknown\\
	\mamid monitors \glspl{slave} in unknown state and sets them into active state if they recover. The \gls{administrator} can set the slave state to maintenance to stop monitoring of the slave or to disabled mode to replace the slave.
	\item \glslink{maintenance mode}{maintenance}\\
	\mamid does not monitor \glspl{slave} in maintenance mode, but also does not alter the \gls{replica set}.
	\item \glslink{disabled mode}{disabled}\\
	\mamid dissociates \glspl{slave} in disabled mode with any \glspl{replica set} they may be member of. This means all mongod instances running on the slave are shut down.
\end{itemize}
All state changes apart from active $\leftrightarrow$ unknown have to be triggered by the \gls{administrator}. If \ref{WK:deploy_arbiters} is implemented the state change unknown $\rightarrow$ disabled can be triggered automatically.

\subsection{Graphical User Interface (GUI)}\label{SM:GUI}
\begin{description}
	%React-JS und so...
	\oitem{SM}{gui_model} GUI::Model\\
	Data structures representing \mamid entities that are displayed or managed through the web interface (\ref{SM:gui_view}). (\ref{F:gui_crud_inventory}, \ref{F:gui_set_slave_type}, \ref{F:gui_set_root_data_dir}, \ref{F:gui_set_phys_interdeps}, \ref{F:gui_set_slave_mode}, \ref{F:gui_crud_replica_sets})
	\oitem{SM}{gui_view} GUI::View\\
	Web interface and its UI elements. (\ref{F:gui_crud_inventory}, \ref{F:gui_crud_replica_sets}, \ref{F:gui_display_errors}, \ref{WF:gui_display_machine_metrics}, \ref{WF:gui_display_repl_status}, \ref{WF:gui_auto_discovery_interface})
	\oitem{SM}{} GUI::Controller\\
	Handles UI interaction, updates model and asserts semantic consistency between \ref{SM:gui_view} and \ref{SM:gui_model}.
\end{description}
\subsection{NotificationManager}\label{SM:NotificationManager}
\begin{description}
	\oitem{SM}{notif_mail} NotificationManager::MailNotifier\\
	Sends e-mail messages. (\ref{F:notifmgr_send_emails})
	\oitem{SM}{notif_apiclient} NotificationManager::APIClient\\
	\acrshort{API} client for \ref{SM:masterapiserver}. (\ref{F:notifmgr_consume_errors})
	\oitem{SM}{notif_controller} NotificationManager::Controller\\
	Uses \ref{SM:notif_apiclient} and \ref{SM:notif_mail} to implement notification of the \glspl{administrator}. (\ref{F:notifmgr_controller_send_errors}, \ref{F:notifmgr_read_conf_file})
\end{description}

\section{Product Data}

\subsection{Inventory (contains slaves)}\label{D:Inventory}
% hostname(PRIMARY KEY) | slaveport | mongod-portrange | persistent/volatile | root data directory | mode (active, maint, disabled)

List of tuples containing the following data

\begin{description}
	\oitem{D}{} hostname
	\oitem{D}{} \gls{slave} port $\in \mathbb{N}$
	\oitem{D}{slave_mongod_portrange} mongod-portrange $\in \{{[i, j]} \mid i,j \in \mathbb{N}\}$ (also specifies how many mongod instances may run on the slave)
	\oitem{D}{} persistency $\in \{\text{\glslink{persistent storage}{persistent}}, \text{\glslink{volatile storage}{volatile}}\}$
	\oitem{D}{} \gls{root data directory}
	\oitem{D}{} mode $\in \{\text{\glslink{active mode}{active}}, \text{\glslink{maintenance mode}{maintenance}}, \text{\glslink{disabled mode}{disabled}}\}$
\end{description}

\subsection{Replica Set Configuration}
%----------------------------- ADMIN SETTABLE ------------------------------------------------------------  ---Allocator settable--  
% replset | p = num of persistent slaves | v = num of volatile slaves | sharding config server (true|false) | p+v mongod processes 
List of tuples containing the following data

\begin{description}
	\oitem{D}{} \gls{replica set} name
	\oitem{D}{} number of \glslink{persistent storage}{persistent} slaves $p$
	\oitem{D}{} number of \glslink{volatile storage}{volatile} slaves $v$
	\oitem{D}{} sharding configuration server $\in \{\text{true}, \text{false}\}$
	\oitem{D}{} member mongod processes (list of $p+v$)
\end{description}

\subsection{MongoDB processes}
%(hostname | port != slaveport) PRIMARY KEY
List of tuples containing the following data

\begin{description}
	\oitem{D}{} hostname
	\oitem{D}{} port
\end{description}

\subsection{Physical Interdependencies}
%sets of slaveids
%Each set marks the contained nodes as physically dependent.
%Disjoint sets!
\begin{description}
	\oitem{D}{} Mutually disjoint sets of \glspl{slave}, denoting which \glspl{slave} must not be member of the same \gls{replica set}.
\end{description}

\section{Product Data Consistencies}

\begin{description}
	%Ports
	\oitem{DC}{} The port of a mongod process must be inside the mongod-portrange of the slave it is running on
	\oitem{DC}{} The combination of mongod hostname and mongod port must be unique
	\oitem{DC}{} The slave port must not be inside the mongod-portrange
	%Arbiters
	\oitem{DC}{} The number of nodes $p+v$ in a replica set must be odd unless \ref{WK:deploy_arbiters} is implemented
\end{description}


\section{Functional Requirements}
% Format: Substantiviertes Verb am Anfang („Bestimmen von X“, nicht „Bestimmung von X“, „Bestimme X“ oder „X bestimmen”).

%TODO cli paramters + config file template wf spezifizieren

\subsection{Graphical User Interface (GUI)}
The \acrshort{gui} acts as a frontend to the functionality provided by \ref{SM:masterapiserver}. Hence, all functionality described in this subsection is realized through \acrshort{API} calls to the \gls{master}.
\begin{description}
	\oitem{F}{gui_crud_inventory} \acrshort{CRUD} \glspl{slave} in \gls{inventory}.
	\oitem{F}{gui_set_slave_type} Specify type of \gls{slave} (\ref{MK:available_slave_types}) upon insertion into \gls{inventory}.
	\oitem{F}{gui_set_root_data_dir} Specify \gls{root data directory} of \glspl{slave} (\ref{MK:root_data_directory}).
	\oitem{F}{gui_set_phys_interdeps} \acrshort{CRUD} \glspl{physical interdependency} (\ref{MK:spec_physical_interdep}) between \glspl{host}.
	\oitem{F}{gui_set_slave_mode} Set mode of \gls{host} to \glslink{active mode}{active}, \glslink{maintenance mode}{maintenance} or \glslink{disabled mode}{disabled}.
	\oitem{F}{gui_crud_replica_sets} \acrshort{CRUD} \gls{replica set} configurations (\ref{MK:replica_set_create}).
	\oitem{F}{gui_display_errors} Display error reports (\ref{F:master_api_error_reports}).
	\oitem{WF}{gui_display_machine_metrics} Display machine metrics of the \glspl{slave}. 
	\oitem{WF}{gui_display_repl_status} Display replication status of the configured \glspl{replica set}.
	\oitem{WF}{gui_auto_discovery_interface} Provide interface to select auto-discovered \glspl{slave} when adding to \gls{inventory} (\ref{F:gui_crud_inventory}).
\end{description}

\subsection{Master}
\subsubsection{API Server}
\begin{description}
	\oitem{F}{master_api_crud_slaves} Provide \acrshort{API} to \acrshort{CRUD} \glspl{slave} in \gls{inventory} (\ref{MK:inventory_definition}).
	\oitem{F}{master_api_crud_phys_interdeps} Provide \acrshort{API} to \acrshort{CRUD} \glspl{physical interdependency} between \glspl{host}.
	\oitem{F}{master_api_set_slave_mode} Provide \acrshort{API} to set mode of \gls{host} to \glslink{active mode}{active}, \glslink{maintenance mode}{maintenance} or \glslink{disabled mode}{disabled}.
	\oitem{F}{master_api_crud_repl_set_config} Provide \acrshort{API} to \acrshort{CRUD} \gls{replica set} configurations (\ref{MK:replica_set_create}, \ref{MK:replica_set_config_profiles}, \ref{MK:replica_set_member_pv_counts}).
	\oitem{F}{master_api_error_reports} Provide \acrshort{API} to retrieve error reports (\ref{MK:detect_slave_unexpected_behavior}).
	\oitem{WF}{master_api_get_auto_discovered_slaves} Provide \acrshort{API} to retrieve a list of auto-discovered \glspl{slave} (\ref{WK:manual_autodiscovery}).
	\oitem{WF}{master_api_machine_metrics} Provide \acrshort{API} exposing machine metrics of the \glspl{slave}.
	\oitem{WF}{master_api_repl_set_status} Provide \acrshort{API} exposing \gls{replica set} replication status of the configured \glspl{replica set}.
\end{description}
\subsubsection{Monitor}
\begin{description}
	\oitem{F}{master_monitor_config} Monitor configuration \& state of \gls{MongoDB} instances running on \gls{cluster} hosts (\ref{MK:detect_slave_unexpected_behavior}).
	\oitem{WF}{master_monitor_icmp} Monitor reachability of \gls{cluster} hosts via \acrshort{ICMP}.
	\oitem{WF}{master_monitor_continuous_auto_discovery} Continuously auto-discover \glspl{slave} on the \gls{cluster} network and add them to the \gls{inventory} (\ref{WK:continuous_autodiscovery}).
\end{description}
\subsubsection{Inventory}
\begin{description}
	\oitem{F}{master_inventory_persist_conf_state} Persist and provide the \gls{cluster} configuration \& state (\gls{inventory}).
\end{description}
\subsubsection{Controller}
\begin{description}
	\oitem{WF}{master_controller_auto_repair} Auto-repair \gls{degraded} \glspl{replica set} utilizing \ref{F:layout_cluster_config}.
\end{description}
\subsubsection{Cluster Allocator}
\begin{description}
	\oitem{F}{layout_cluster_config} Lay out the \gls{cluster} configuration, i.e. decide on a \gls{replica set} configuration
	\begin{description}
		\oitem{F}{master_alloc_resp_phys_interdeps} respecting physical interdependencies between \gls{cluster} hosts (\ref{MK:spec_physical_interdep}).
		\oitem{F}{master_alloc_resp_mode} respecting the mode of hosts (\ref{MK:slave_mode_disabled}).
		\oitem{F}{master_alloc_resp_pv_counts} respecting the administrator-configured number of $p$ persistent \& $v$ volatile \gls{replica set} members per \gls{replica set}, given that
			\begin{flalign*} %align left
			p \in \mathbb{N}_0 \text{ persistent members}  \\
			v \in \mathbb{N}_0 \text{ volatile members} \\
			(p+v) >= 3 \land (p+v) \text{ odd}
			\end{flalign*}
			(\ref{MK:replica_set_member_pv_counts} and \ref{MK:available_slave_types})
		\oitem{WF}{master_alloc_arbiters} adding \gls{MongoDB} \glspl{arbiter} where necessary (\ref{WK:deploy_arbiters}).
	\end{description}
	\oitem{F}{master_alloc_communicate_config} Communicate the \gls{MongoDB} instance configuration to the \glspl{slave} (\ref{MK:mongod_deployment1}).
\end{description}

\subsection{MasterSlaveProtocol}
\begin{description}
	\oitem{F}{msp_trans_config} Transport \gls{replica set} configuration description of \gls{cluster} hosts.
	\oitem{F}{msp_trans_reachability} Transport reachability check messages.
	\oitem{WF}{msp_trans_mach_metr} Transport machine metrics of \glspl{slave}.
	\oitem{WF}{msp_trans_repl_status} Transport \gls{replica set} replication status of \gls{MongoDB} processes on \glspl{slave}.
	% Wunschkriterien erweiteretes Monitoring
\end{description}

\subsection{Slave}
\begin{description}
	% Controller
	\oitem{F}{slave_enforce_config} Apply \gls{MongoDB} process configuration description received from \gls{master} through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol} (\ref{MK:mongod_deployment1}).
	% Process manager
	\oitem{F}{slave_control_procs} Spawn / Control / Kill \gls{MongoDB} processes (\ref{MK:mongod_deployment2}).
	% MongoDB Client
	\oitem{F}{slave_communicate_with_mongodb} Communicate with \gls{MongoDB} processes using \hyperref[SM:mongodbclient]{MongoDBClient}.
	% Controller again
	\oitem{F}{slave_report_config} Report current configuration through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol}.
	\oitem{WF}{slave_report_machine_metrics} Report machine metrics through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol}.
	\oitem{WF}{slave_report_repl_status} Report \gls{replica set} replication status through \hyperref[SM:masterslaveproto]{MasterSlaveProtocol}.
\end{description}

\subsection{NotificationManager}
\begin{description}
	% API Client
	\oitem{F}{notifmgr_consume_errors} Consume error reporting \acrshort{API} of \gls{master} \ref{F:master_api_error_reports}.
	% Controller
	\oitem{F}{notifmgr_controller_send_errors} Send error reports from \ref{F:master_api_error_reports} to configured list of contacts.
	\oitem{F}{notifmgr_read_conf_file} Read list of contacts from a text-based configuration file.
	% Mail Notifier
	\oitem{F}{notifmgr_send_emails} Send error reports via e-mail messages to a contact's address.
\end{description}

\subsection{Command Line Interface (CLI)}
The \acrshort{cli} is an \emph{optional} functional requirement. It acts as a frontend to the functionality provided by \ref{SM:masterapiserver}. Hence, all functionality described in this subsection is realized through \acrshort{API} calls to the \gls{master}.
\begin{description}
	\oitem{WF}{cli_crud_inventory} \acrshort{CRUD} \glspl{slave} in (\gls{inventory}).
	\oitem{WF}{cli_set_slave_type} Specify type of slave (\ref{MK:available_slave_types}) on insertion into \gls{inventory}.
	\oitem{WF}{cli_set_root_data_dir} Specify \gls{root data directory} of \glspl{slave} (\ref{MK:root_data_directory}).
	\oitem{WF}{cli_set_phys_interdeps} \acrshort{CRUD} \glspl{physical interdependency} (\ref{MK:spec_physical_interdep}) between \glspl{host}.
	\oitem{WF}{gui_set_slave_mode} Set mode of \gls{host} to \glslink{active mode}{active}, \glslink{maintenance mode}{maintenance} or \glslink{disabled mode}{disabled}.
	\oitem{WF}{cli_crud_replica_sets} \acrshort{CRUD} \gls{replica set} configurations (\ref{MK:replica_set_create}).
	\oitem{WF}{cli_display_errors} Display error reports (\ref{F:master_api_error_reports}).
	\oitem{WF}{cli_display_machine_metrics} Display machine metrics of the \glspl{slave}. 
	\oitem{WF}{cli_display_repl_status} Display replication status of the configured \glspl{replica set}.
\end{description}

\section{Non-Functional Requirements and Constraints}

\subsection{Non-Functional Requirements}
\begin{description}
	% Usability
	\oitem{NF}{} The \gls{administrator} does not need extended knowledge of \gls{MongoDB} to configure \glspl{replica set} using \mamid.
	\oitem{NF}{} The \acrshort{gui} needs to be intuitive to \glspl{administrator} familiar with similar tools.
	% Reliability
	\oitem{NF}{} \mamid can handle an unordered parallel reboot of an arbitrary of hosts in the cluster.
	\oitem{NF}{} The \gls{cluster} is resilient against unexpected failures of \glspl{slave}.
	% Performance
	\oitem{NF}{} The \acrshort{gui} responds to user interaction within $500ms$.
	\oitem{NF}{} \mamid supports at least 100 \glspl{slave} in the \gls{cluster}.
	% Maintainability
\end{description}

\subsection{Constraints}
\begin{description}
	\oitem{NF}{} The \hyperref[SM:masterapiserver]{Master API} protocol is \acrshort{JSON} over \acrshort{HTTP}.
	\oitem{NF}{} The \hyperref[SM:masterapiserver]{Master API} is stateless.
	\oitem{NF}{} Implementation Languages
	\begin{itemize}
		\item Golang (\hyperref[SM:Master]{Master}, \hyperref[SM:Slave]{Slave}, \hyperref[SM:MasterSlaveProtocol]{MasterSlaveProtocol}, \hyperref[SM:NotificationManager]{NotificationManager})
		\item HTML, CSS, JavaScript (\hyperref[SM:GUI]{GUI})
	\end{itemize}
	\oitem{NF}{} Team Communication: Slack, GitHub, E-mail
	\oitem{NF}{} Documentation: \LaTeX{}
	\oitem{NF}{} UML-Designer UMLet
	\oitem{NF}{} Version Control: Git
	%TODO \item[Quality Assurance] ... %TODO
\end{description}

\section{Graphical User Interface (GUI)}
%Form:
%Name [: Beschreibung]
%Beschreibung: satz ohne subjekt, also klein und ohne Punkt; Strichpunkt getrennt

%\begin{enumerate}
%\item
%\end{enumerate}

%text...

\section{Test Cases and Scenarios}
% Vorbedinung, Aktionen, Nachbedingung 
\subsection{Test Cases}
Bei allen Testfällen gilt als Vorbedingung, dass \mamid gestartet ist (außer es ist explizit gefordert, dass es gestoppt ist).
\begin{description}
\itemsep 1em
\subsubsection{Kernfunktionen}
\oitem{TF}{testen} a testcase.
\testfall[\ref{WK:beschlArc}] %testet:
    {foo} %vorbedingung
    {bar} % ablauf
    {jon} % erwa. ergebnis
\end{description}
\subsection{Scenarios}
% all. vorbed.
Unless explicitly stated, the \acrshort{gui}'s home page is always opened in the tester's browser. %TODO ref home page

\begin{description}

\oitem{TS}{} Adding Machines to the Cluster
\testsequence
[\ref{F:gui_crud_inventory}, \ref{F:master_api_crud_slaves}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}]
{
	A machine $M$ with installed \gls{slave} software is connected to the \gls{cluster} network. The \gls{administrator} configures that the \gls{slave} software is started on boot.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the 'slave management section' in the \hyperref[SM:GUI]{GUI}.
		\item The \gls{administrator} adds the slave $S$ on $M$ using the 'add slave form'. %TODO ref testseq and ui
		\item The \gls{administrator} sets $S$ from \gls{disabled mode} to \gls{active mode}.
	\end{itemize}
}

\oitem{TS}{} Removing Machines from the Cluster
\testsequence
[\ref{F:gui_crud_inventory}, \ref{F:master_api_crud_slaves}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_communicate_config}]
{
	A machine $M$ with installed \gls{slave} software shall be removed from the cluster.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the 'slave management section' in the \hyperref[SM:GUI]{GUI}.
		\item The \gls{administrator} selects the \gls{slave} $S$ and sets it to \gls{disabled mode}. %TODO ref testseq and ui
		\item The \hyperref[SM:Master]{master} determines a new \gls{cluster} layout to repair $S$'s former \glspl{replica set}.
		\item The \hyperref[SM:Master]{master} communicates the desired configuration to the appropriate \glspl{slave}.
		\item The \hyperref[SM:GUI]{GUI} now allows the \gls{administrator} to delete $S$ from the \gls{inventory}.
		\item The \gls{administrator} deletes $S$ from the \gls{inventory}. %TODO ref testseq and ui
		\item The \gls{administrator} can now physically remove $M$ from the \gls{cluster}.
	\end{itemize}
}


\oitem{TS}{} Temporarily Unreachable Slave
\testsequence
[\ref{F:master_monitor_config}, \ref{F:master_api_error_reports}, \ref{F:gui_display_errors}, \ref{F:gui_set_slave_mode}, \ref{F:msp_trans_reachability}]
{
	A \gls{slave} $S$ becomes unreachable because of broken network cable.
}
{
	\begin{itemize}
		\item \hyperref[SM:NotificationManager]{NotificationManager} sends an e-mail notification to the \gls{administrator}.
		\item \glslink{administrator}{Administrator} responds to the e-mail notification by opening the 'error reports' section in the web interface. %TODO ref
		\item \hyperref[SM:GUI]{GUI} offers to set $S$ into \glslink{maintenance mode}{maintenance} or \gls{disabled mode}.
		\item \glslink{administrator}{Administrator} does not choose either of the options but replaces the broken cable.
		\item \hyperref[SM:Master]{Master} reaches $S$ again.
		\item \hyperref[SM:Master]{Master} determines that configuration is still as expected.
		\item \hyperref[SM:Master]{Master} removes $S$ from the error report.
	\end{itemize}
}


\oitem{TS}{} Defective Slave
\testsequence
[\ref{F:master_monitor_config}, \ref{F:master_api_error_reports}, \ref{F:gui_display_errors}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:slave_report_config}, \ref{F:msp_trans_config}, \ref{F:msp_trans_reachability}, \ref{F:master_monitor_config}]
{
	A \gls{slave} $S$ becomes permanently unreachable because there was a short-circuit on its mainboard which needs to be replaced. The admin has no spare mainboards left and has to wait for replacement hardware to arrive. However, there is at least one \glslink{active mode}{active} \gls{slave} allowed to take over the role of the failed one.
}
{
	\begin{itemize}
		\item After $S$ becomes unavailable the \hyperref[SM:NotificationManager]{NotificationManager} sends an e-mail notification to the \gls{administrator}.
		\item \glslink{administrator}{Administrator} responds to e-mail notification by opening the 'error reports' section in web interface %TODO ref
		\item \hyperref[SM:GUI]{GUI} offers to set $S$ into \glslink{maintenance mode}{maintenance} or \gls{disabled mode}.
		\item \glslink{administrator}{Administrator} chooses \gls{disabled mode}.
		\item \hyperref[SM:Master]{Master} selects a \gls{slave} $S'$ as a replacement for $S$ and communicates the appropriate configuration to $S'$
		\item $S'$ starts a new \gls{MongoDB} process and enforces the received configuration.
		\item $S'$ reports successful configuration to \hyperref[SM:Master]{master}.
		\item \hyperref[SM:Master]{Master} removes $S$ from the error report.
	\end{itemize}
}


\oitem{TS}{} System Maintenance
\testsequence
[\ref{F:gui_crud_inventory}, \ref{F:master_api_crud_slaves}, \ref{F:gui_set_slave_mode}, \ref{F:master_api_set_slave_mode}, \ref{F:master_inventory_persist_conf_state}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:slave_report_config}, \ref{F:msp_trans_config}]
{
	A \gls{slave} $S$ needs to be rebooted to install security updates to the installed software.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to the 'slave management section' in the \hyperref[SM:GUI]{GUI}. %TODO ui ref
		\item The \gls{administrator} selects $S$ and sets it to \gls{maintenance mode}.
		\item The \gls{administrator} installs the security updates and reboots the machine (killing the \gls{slave} instance and all its \gls{MongoDB} instances).
		\item The \gls{slave} process $S$ is restarted by the system's service manager after reboot.
		\item The \gls{administrator} sets $S$ back to \gls{active mode}.
		\item The \hyperref[SM:Master]{master} communicates the desired configuration to $S$.
		\item $S$ starts the \gls{MongoDB} processes and configures \gls{replica set} membership if required by the communicated configuration.
	\end{itemize}
}


\oitem{TS}{} Adding a Replica Set
\testsequence
[\ref{F:gui_crud_replica_sets}, \ref{F:master_api_crud_repl_set_config}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:msp_trans_config}]
{
	The \gls{administrator} wants to add a \gls{replica set} with $p \in \mathbb{N}$ \glslink{persistent storage}{persistent} members and $v \in \mathbb{N}$ \glslink{volatile storage}{volatile} members. $(p+v) >= 3 \land (p+v) is odd$. Enough \glspl{slave} with sufficient free \gls{MongoDB} \hyperref[D:slave_mongod_portrange]{ports} are available.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to 'replica set management section'. %TODO ref ui
		\item The \gls{administrator} adds a new replica set $R$ using the 'add replica set form' with constraints $p$ and $v$. %TODO ref ui and testsequence
		\item The \hyperref[SM:Master]{master} finds appropriate \glspl{slave} for hosting members of $R$ (\hyperref[SM:master_clusterallocator]{Master::ClusterAllocator}).
		\item The \hyperref[SM:Master]{master} communicates the desired configuration to the appropriate \glspl{slave} $Z$.
		\item The \glspl{slave} in $Z$ apply the received configuration.
	\end{itemize}
}

\oitem{TS}{} Destroying a Replica Set
\testsequence
[\ref{F:gui_crud_replica_sets}, \ref{F:master_api_crud_repl_set_config}, \ref{F:layout_cluster_config}, \ref{F:master_alloc_resp_pv_counts}, \ref{F:master_alloc_resp_mode}, \ref{F:master_alloc_communicate_config}, \ref{F:slave_control_procs}, \ref{F:slave_enforce_config}, \ref{F:msp_trans_config}]
{
	The \gls{administrator} wants to destroy a \gls{replica set} $R$.
}
{
	\begin{itemize}
		\item The \gls{administrator} navigates to 'replica set management section'. %TODO ref ui
		\item The \gls{administrator} selects $R$ and clicks the remove button. % TODO ref testseq and ui
		\item The \hyperref[SM:GUI]{GUI} prompts the \gls{administrator} for confirmation.
		\item The \gls{administrator} confirms the removal.
		\item The \hyperref[SM:Master]{master} persists the change and communicates to the \glspl{slave} that \gls{host} members of $R$ must kill the respective \gls{MongoDB} processes.
		\item The \glspl{slave} apply the received instructions.
	\end{itemize}
}

\end{description}


\newpage
\glsaddallunused
\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space On page ##5.
  }
}
\makeatother
\glsaddall
\printglossary[type=main, title={Glossary}, toctitle={Glossary}, style=myAltlist]

\end{document}
